The following is a digest of the repository "BackEnd_Discord".
This digest is designed to be easily parsed by Large Language Models.

--- SUMMARY ---
Repository: BackEnd_Discord
Files Analyzed: 103
Total Text Size: 161.81 KB
Estimated Tokens (text only): ~46,867

--- DIRECTORY STRUCTURE ---
BackEnd_Discord/
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ API_DOCUMENTATION.md
â”‚   â”œâ”€â”€ BACKEND_ARCHITECTURE.md
â”‚   â”œâ”€â”€ QUICK_START_GUIDE.md
â”‚   â”œâ”€â”€ README.md
â”‚   â”œâ”€â”€ REDIS_PRESENCE_SYSTEM.md
â”‚   â”œâ”€â”€ SOCKET_IO_GUIDE.md
â”‚   â”œâ”€â”€ STATUS_SYSTEM.md
â”‚   â””â”€â”€ WEBSOCKET_POSTMAN_TESTING.md
â”œâ”€â”€ postman/
â”‚   â”œâ”€â”€ User1_Alice.postman_collection.json
â”‚   â”œâ”€â”€ User2_Bob.postman_collection.json
â”‚   â”œâ”€â”€ User3_Charlie.postman_collection.json
â”‚   â””â”€â”€ WebSocket_Testing.postman_collection.json
â”œâ”€â”€ prisma/
â”‚   â”œâ”€â”€ migrations/
â”‚   â”‚   â””â”€â”€ migration_lock.toml
â”‚   â””â”€â”€ schema.prisma
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ common/
â”‚   â”‚   â”œâ”€â”€ bootstrap/
â”‚   â”‚   â”‚   â”œâ”€â”€ app.bootstrap.ts [binary]
â”‚   â”‚   â”‚   â””â”€â”€ index.ts [binary]
â”‚   â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”‚   â”œâ”€â”€ app.config.ts [binary]
â”‚   â”‚   â”‚   â”œâ”€â”€ bootstrap.config.ts [binary]
â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts [binary]
â”‚   â”‚   â”‚   â””â”€â”€ swagger.config.ts [binary]
â”‚   â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ User/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ friendship.repository.ts [binary]
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts [binary]
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ presence.repository.ts [binary]
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ user-relation.repository.ts [binary]
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ user-status-record.repository.ts [binary]
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ user.repository.ts [binary]
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ index.ts [binary]
â”‚   â”‚   â”‚   â”œâ”€â”€ database.module.ts [binary]
â”‚   â”‚   â”‚   â”œâ”€â”€ prisma.middleware.ts [binary]
â”‚   â”‚   â”‚   â””â”€â”€ prisma.service.ts [binary]
â”‚   â”‚   â”œâ”€â”€ decorators/
â”‚   â”‚   â”‚   â”œâ”€â”€ auth-user.decorator.ts [binary]
â”‚   â”‚   â”‚   â”œâ”€â”€ date-transform.decorator.ts [binary]
â”‚   â”‚   â”‚   â”œâ”€â”€ is-emoji.decorator.ts [binary]
â”‚   â”‚   â”‚   â””â”€â”€ websocket-auth.decorator.ts [binary]
â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â”œâ”€â”€ auth-response.dto.ts [binary]
â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts [binary]
â”‚   â”‚   â”‚   â””â”€â”€ shared-response.dto.ts [binary]
â”‚   â”‚   â”œâ”€â”€ filters/
â”‚   â”‚   â”‚   â”œâ”€â”€ catchAll.filter.ts [binary]
â”‚   â”‚   â”‚   â””â”€â”€ customHttpException.filter.ts [binary]
â”‚   â”‚   â”œâ”€â”€ Global/
â”‚   â”‚   â”‚   â”œâ”€â”€ cache/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ User/
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ friends-cache.service.ts [binary]
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ redis.service.ts [binary]
â”‚   â”‚   â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ cache.config.ts [binary]
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ database.config.ts [binary]
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ env.validation.ts [binary]
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ jwt.config.ts [binary]
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ main.config.ts [binary]
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ security.config.ts [binary]
â”‚   â”‚   â”‚   â”œâ”€â”€ Interceptors/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ BigInt.interceptors.ts [binary]
â”‚   â”‚   â”‚   â”œâ”€â”€ security/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ cryption.helper.ts [binary]
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ hash.helper.ts [binary]
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts [binary]
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ jwt.helper.ts [binary]
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ zod.validator.ts [binary]
â”‚   â”‚   â”‚   â”œâ”€â”€ validators/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ isId.validator.ts [binary]
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ IsValidBirthdate.validator.ts [binary]
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ username.validator.ts [binary]
â”‚   â”‚   â”‚   â””â”€â”€ global.module.ts [binary]
â”‚   â”‚   â”œâ”€â”€ guards/
â”‚   â”‚   â”‚   â””â”€â”€ auth.guards.ts [binary]
â”‚   â”‚   â”œâ”€â”€ interceptors/
â”‚   â”‚   â”‚   â””â”€â”€ transform.interceptor.ts [binary]
â”‚   â”‚   â”œâ”€â”€ shared/
â”‚   â”‚   â”‚   â”œâ”€â”€ response-messages.ts [binary]
â”‚   â”‚   â”‚   â””â”€â”€ types.ts [binary]
â”‚   â”‚   â”œâ”€â”€ Types/
â”‚   â”‚   â”‚   â”œâ”€â”€ message.ts [binary]
â”‚   â”‚   â”‚   â”œâ”€â”€ presence.types.ts [binary]
â”‚   â”‚   â”‚   â””â”€â”€ websocket.types.ts [binary]
â”‚   â”‚   â””â”€â”€ utils/
â”‚   â”‚       â”œâ”€â”€ response.util.ts [binary]
â”‚   â”‚       â”œâ”€â”€ snowflake.ts [binary]
â”‚   â”‚       â””â”€â”€ validation.util.ts [binary]
â”‚   â”œâ”€â”€ modules/
â”‚   â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”‚   â”œâ”€â”€ decorators/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ auth-api.decorators.ts [binary]
â”‚   â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ auth.dto.ts [binary]
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.controller.ts [binary]
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.module.ts [binary]
â”‚   â”‚   â”‚   â””â”€â”€ auth.service.ts [binary]
â”‚   â”‚   â”œâ”€â”€ health/
â”‚   â”‚   â”‚   â”œâ”€â”€ health.controller.ts [binary]
â”‚   â”‚   â”‚   â”œâ”€â”€ health.module.ts [binary]
â”‚   â”‚   â”‚   â””â”€â”€ health.service.ts [binary]
â”‚   â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”‚   â””â”€â”€ v1/
â”‚   â”‚   â”‚       â”œâ”€â”€ decorators/
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ user-api.decorators.ts [binary]
â”‚   â”‚   â”‚       â”œâ”€â”€ dto/
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ user-response.dto.ts [binary]
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ user-types.dto.ts [binary]
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ user.dto.ts [binary]
â”‚   â”‚   â”‚       â”œâ”€â”€ users.controller.ts [binary]
â”‚   â”‚   â”‚       â”œâ”€â”€ users.module.ts [binary]
â”‚   â”‚   â”‚       â””â”€â”€ users.service.ts [binary]
â”‚   â”‚   â””â”€â”€ websocket/
â”‚   â”‚       â”œâ”€â”€ User/
â”‚   â”‚       â”‚   â”œâ”€â”€ auth/
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ auth.service.ts [binary]
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ connection.handler.ts [binary]
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ index.ts [binary]
â”‚   â”‚       â”‚   â”œâ”€â”€ friends/
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ friends.service.ts [binary]
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ friendship-notifier.service.ts [binary]
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ index.ts [binary]
â”‚   â”‚       â”‚   â”œâ”€â”€ presence/
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ broadcaster.service.ts [binary]
â”‚   â”‚       â”‚   â”œâ”€â”€ services/
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ unified-presence.service.ts [binary]
â”‚   â”‚       â”‚   â”œâ”€â”€ index.ts [binary]
â”‚   â”‚       â”‚   â””â”€â”€ websocket.gateway.ts [binary]
â”‚   â”‚       â””â”€â”€ websocket.module.ts [binary]
â”‚   â”œâ”€â”€ app.module.ts [binary]
â”‚   â””â”€â”€ main.ts [binary]
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ app.e2e-spec.ts [binary]
â”‚   â””â”€â”€ jest-e2e.json
â”œâ”€â”€ eslint.config.mjs
â”œâ”€â”€ nest-cli.json
â”œâ”€â”€ package.json
â”œâ”€â”€ README.md
â”œâ”€â”€ tsconfig.build.json
â””â”€â”€ tsconfig.json


--- FILE CONTENTS ---
============================================================
FILE: docs/API_DOCUMENTATION.md
============================================================
# Discord Clone API Documentation

## ğŸ“‹ Table of Contents
1. [Overview](#overview)
2. [Base URL & Authentication](#base-url--authentication)
3. [Data Types & Validation](#data-types--validation)
4. [Response Format](#response-format)
5. [Authentication APIs](#authentication-apis)
6. [User Profile APIs](#user-profile-apis)
7. [Friendship APIs](#friendship-apis)
8. [User Relations APIs](#user-relations-apis)
9. [Error Handling](#error-handling)
10. [Frontend Integration Guide](#frontend-integration-guide)

---

## Overview

This is a Discord Clone backend API built with NestJS, Prisma, and PostgreSQL. The API provides user authentication, profile management, friendship system, and user relations (block, mute, ignore).

**Tech Stack:**
- NestJS (Node.js framework)
- Prisma (ORM)
- PostgreSQL (Database)
- **Redis** (Presence & Caching) â­
- JWT (Authentication)
- Socket.IO (WebSocket)
- Class Validator (Validation)

**Key Feature:**
- **Redis-Based Presence System** - Ù†Ø¸Ø§Ù… presence Ù…Ø«Ù„ Discord ØªÙ…Ø§Ù…Ø§Ù‹ØŒ ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Redis ÙÙ‚Ø· (volatile) ÙˆÙ„ÙŠØ³ Ø¹Ù„Ù‰ Database

---

## Base URL & Authentication

### Base URL
```
http://localhost:3000/api/v1
```

### Authentication
All protected endpoints require a JWT token in the Authorization header:

```http
Authorization: Bearer <your_jwt_token>
```

**Token Format:**
- Access Token: Used for API requests
- Refresh Token: Used to get new access tokens

---

## Data Types & Validation

### User ID Format
- **Type:** String
- **Format:** 16-19 digits (Snowflake ID)
- **Example:** `"123456789012345678"`
- **Validation:** Must match regex `/^\d{16,19}$/`

### Username Format
- **Type:** String
- **Length:** 3-32 characters
- **Allowed Characters:** Letters (a-z, A-Z), numbers (0-9), underscores (_), dots (.)
- **Reserved Words:** `admin`, `support`, `discord`, `system`
- **Example:** `"john_doe"`, `"user123"`, `"alice.dev"`
- **Validation:** Must match regex `/^[a-zA-Z0-9._]+$/`

### Email Format
- **Type:** String
- **Format:** Valid email address
- **Example:** `"user@example.com"`

### Password Format
- **Type:** String
- **Requirements:** Strong password (at least 8 characters, uppercase, lowercase, number, special character)
- **Example:** `"MyPassword123!"`

### Date Format
- **Type:** Date
- **Format:** ISO 8601 (`YYYY-MM-DD`)
- **Example:** `"2002-10-26"`

### Enums

#### User Status
```typescript
enum UserStatus {
  ONLINE = "ONLINE"
  OFFLINE = "OFFLINE"
  IDLE = "IDLE"
  DND = "DND" // Do Not Disturb
}
```

#### Friendship Status
```typescript
enum FriendshipStatus {
  PENDING = "PENDING"
  ACCEPTED = "ACCEPTED"
}
```

#### Relation Type
```typescript
enum RelationType {
  BLOCKED = "BLOCKED"
  IGNORED = "IGNORED"
  MUTED = "MUTED"
}
```

---

## Response Format

### Success Response
```json
{
  "status": "success",
  "code": 200,
  "message": "Operation completed successfully",
  "data": {
    // Response data here
  },
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### Error Response
```json
{
  "status": "error",
  "code": 400,
  "message": "Validation failed",
  "errors": [
    {
      "field": "username",
      "message": "Username must be at least 3 characters long",
      "value": "ab"
    }
  ],
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### Validation Error Response
```json
{
  "status": "fail",
  "code": 422,
  "message": "Validation failed",
  "errors": [
    {
      "field": "email",
      "message": "Email must be a valid email address",
      "value": "invalid-email"
    }
  ],
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

---

## Authentication APIs

### 1. Register User

**Endpoint:** `POST /auth/register`

**Description:** Create a new user account

**Request Body:**
```json
{
  "username": "john_doe",
  "email": "john@example.com",
  "password": "MyPassword123!",
  "birthdate": "2002-10-26"
}
```

**Validation Rules:**
- `username`: Required, 3-32 chars, alphanumeric + underscore + dot
- `email`: Required, valid email format
- `password`: Required, strong password
- `birthdate`: Required, valid date, must be in the past

**Success Response (201):**
```json
{
  "status": "success",
  "code": 201,
  "message": "User registered successfully",
  "data": {
    "user": {
      "id": "123456789012345678",
      "username": "john_doe",
      "email": "john@example.com",
      "globalname": null,
      "phone": null,
      "avatar": null,
      "status": "OFFLINE",
      "customStatus": null,
      "isBot": false,
      "birthdate": "2002-10-26T00:00:00.000Z",
      "createdAt": "2024-01-15T10:30:00.000Z",
      "updatedAt": "2024-01-15T10:30:00.000Z"
    },
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  },
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

**Error Responses:**
- `400`: Username already exists
- `400`: Email already exists
- `422`: Validation errors

### 2. Login User

**Endpoint:** `POST /auth/login`

**Description:** Authenticate user and get tokens

**Request Body:**
```json
{
  "email": "john@example.com",
  "password": "MyPassword123!"
}
```

**Validation Rules:**
- `email`: Required, valid email format
- `password`: Required, strong password

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "Login successful",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  },
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

**Error Responses:**
- `401`: Invalid credentials
- `422`: Validation errors

---

## User Profile APIs

### 1. Get User Profile

**Endpoint:** `GET /users/profile`

**Description:** Get current user's profile information

**Headers:**
```http
Authorization: Bearer <access_token>
```

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "Profile retrieved successfully",
  "data": {
    "id": "123456789012345678",
    "username": "john_doe",
    "globalname": "John Doe",
    "email": "john@example.com",
    "phone": "+1234567890",
    "avatar": "https://example.com/avatar.jpg",
    "isOnline": true,
    "status": "ONLINE",
    "customStatus": "Playing Minecraft",
    "isBot": false,
    "birthdate": "2002-10-26T00:00:00.000Z",
    "createdAt": "2024-01-15T10:30:00.000Z",
    "updatedAt": "2024-01-15T10:30:00.000Z"
  },
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

**Important Notes:**
- `isOnline`: Comes from **Redis** (real-time connection status), NOT from database
- `status`: Display status from **Redis** (ONLINE, IDLE, DND, Invisible)
- These values reflect the **actual current state** of the user

### 2. Update Password

**Endpoint:** `PUT /users/profile/password`

**Description:** Update user password

**Headers:**
```http
Authorization: Bearer <access_token>
Content-Type: application/json
```

**Request Body:**
```json
{
  "currentPassword": "OldPassword123!",
  "newPassword": "NewPassword123!"
}
```

**Validation Rules:**
- `currentPassword`: Required, strong password
- `newPassword`: Required, strong password

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "Password updated successfully",
  "data": {
    "id": "123456789012345678",
    "username": "john_doe",
    "updatedAt": "2024-01-15T10:30:00.000Z"
  },
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 3. Update Global Name

**Endpoint:** `PUT /users/profile/global-name`

**Description:** Update user's global display name

**Headers:**
```http
Authorization: Bearer <access_token>
Content-Type: application/json
```

**Request Body:**
```json
{
  "globalname": "John Doe"
}
```

**Validation Rules:**
- `globalname`: Optional, max 32 characters

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "Global name updated successfully",
  "data": {
    "id": "123456789012345678",
    "username": "john_doe",
    "globalname": "John Doe",
    "updatedAt": "2024-01-15T10:30:00.000Z"
  },
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 4. Update Custom Status

**Endpoint:** `PUT /users/profile/custom-status`

**Description:** Update user's custom status message

**Headers:**
```http
Authorization: Bearer <access_token>
Content-Type: application/json
```

**Request Body:**
```json
{
  "customStatus": "Playing Minecraft"
}
```

**Validation Rules:**
- `customStatus`: Optional, max 128 characters

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "Custom status updated successfully",
  "data": {
    "id": "123456789012345678",
    "username": "john_doe",
    "customStatus": "Playing Minecraft",
    "updatedAt": "2024-01-15T10:30:00.000Z"
  },
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 5. Update Username

**Endpoint:** `PUT /users/profile/username`

**Description:** Update user's username

**Headers:**
```http
Authorization: Bearer <access_token>
Content-Type: application/json
```

**Request Body:**
```json
{
  "username": "john_doe_2024"
}
```

**Validation Rules:**
- `username`: Required, 3-32 chars, alphanumeric + underscore + dot, not reserved

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "Username updated successfully",
  "data": {
    "id": "123456789012345678",
    "username": "john_doe_2024",
    "updatedAt": "2024-01-15T10:30:00.000Z"
  },
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

---

## Friendship APIs

### 1. Send Friend Request

**Endpoint:** `POST /users/friends/request`

**Description:** Send a friend request to another user

**Headers:**
```http
Authorization: Bearer <access_token>
Content-Type: application/json
```

**Request Body:**
```json
{
  "username": "jane_doe"
}
```
OR
```json
{
  "userId": "987654321098765432"
}
```

**Validation Rules:**
- Either `username` OR `userId` is required (not both)
- `username`: Valid username format
- `userId`: Valid ID format (16-19 digits)

**Success Response (201):**
```json
{
  "status": "success",
  "code": 201,
  "message": "Friend request sent successfully",
  "data": {
    "id": "123456789012345678",
    "user1Id": "123456789012345678",
    "user2Id": "987654321098765432",
    "status": "PENDING",
    "createdAt": "2024-01-15T10:30:00.000Z",
    "updatedAt": "2024-01-15T10:30:00.000Z"
  },
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 2. Respond to Friend Request

**Endpoint:** `PUT /users/friends/respond`

**Description:** Accept or reject a friend request

**Headers:**
```http
Authorization: Bearer <access_token>
Content-Type: application/json
```

**Request Body:**
```json
{
  "friendshipId": "123456789012345678",
  "status": "ACCEPTED"
}
```

**Validation Rules:**
- `friendshipId`: Required, valid ID format
- `status`: Required, must be "ACCEPTED" or "REJECTED"

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "Friend request responded successfully",
  "data": {
    "id": "123456789012345678",
    "user1Id": "123456789012345678",
    "user2Id": "987654321098765432",
    "status": "ACCEPTED",
    "createdAt": "2024-01-15T10:30:00.000Z",
    "updatedAt": "2024-01-15T10:30:00.000Z"
  },
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 3. Get Friends List

**Endpoint:** `GET /users/friends`

**Description:** Get user's friends list

**Headers:**
```http
Authorization: Bearer <access_token>
```

**Query Parameters:**
- `status` (optional): Filter by friendship status (PENDING, ACCEPTED)
- `page` (optional): Page number for pagination
- `limit` (optional): Number of items per page

**Example:**
```
GET /users/friends?status=ACCEPTED&page=1&limit=20
```

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "Friends list retrieved successfully",
  "data": [
    {
      "id": "123456789012345678",
      "user1Id": "123456789012345678",
      "user2Id": "987654321098765432",
      "status": "ACCEPTED",
      "createdAt": "2024-01-15T10:30:00.000Z",
      "updatedAt": "2024-01-15T10:30:00.000Z",
      "friend": {
        "id": "987654321098765432",
        "username": "jane_doe",
        "globalname": "Jane Doe",
        "avatar": "https://example.com/avatar.jpg",
        "status": "ONLINE"
      }
    }
  ],
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 4. Get Incoming Friend Requests

**Endpoint:** `GET /users/friends/requests/incoming`

**Description:** Get pending friend requests received by the user

**Headers:**
```http
Authorization: Bearer <access_token>
```

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "Incoming friend requests retrieved successfully",
  "data": [
    {
      "id": "123456789012345678",
      "user1Id": "987654321098765432",
      "user2Id": "123456789012345678",
      "status": "PENDING",
      "createdAt": "2024-01-15T10:30:00.000Z",
      "updatedAt": "2024-01-15T10:30:00.000Z",
      "requester": {
        "id": "987654321098765432",
        "username": "jane_doe",
        "globalname": "Jane Doe",
        "avatar": "https://example.com/avatar.jpg",
        "status": "ONLINE"
      }
    }
  ],
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 5. Get Outgoing Friend Requests

**Endpoint:** `GET /users/friends/requests/outgoing`

**Description:** Get pending friend requests sent by the user

**Headers:**
```http
Authorization: Bearer <access_token>
```

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "Outgoing friend requests retrieved successfully",
  "data": [
    {
      "id": "123456789012345678",
      "user1Id": "123456789012345678",
      "user2Id": "987654321098765432",
      "status": "PENDING",
      "createdAt": "2024-01-15T10:30:00.000Z",
      "updatedAt": "2024-01-15T10:30:00.000Z",
      "target": {
        "id": "987654321098765432",
        "username": "jane_doe",
        "globalname": "Jane Doe",
        "avatar": "https://example.com/avatar.jpg",
        "status": "ONLINE"
      }
    }
  ],
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 6. Get Mutual Friends

**Endpoint:** `GET /users/friends/mutual/{userId}`

**Description:** Get mutual friends with another user

**Headers:**
```http
Authorization: Bearer <access_token>
```

**Path Parameters:**
- `userId`: The ID of the user to get mutual friends with

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "Mutual friends retrieved successfully",
  "data": [
    {
      "id": "111111111111111111",
      "username": "mutual_friend",
      "globalname": "Mutual Friend",
      "avatar": "https://example.com/avatar.jpg",
      "status": "ONLINE"
    }
  ],
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 7. Check Friendship Status

**Endpoint:** `GET /users/friends/check/{userId}`

**Description:** Check friendship status with another user

**Headers:**
```http
Authorization: Bearer <access_token>
```

**Path Parameters:**
- `userId`: The ID of the user to check friendship with

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "Friendship status checked successfully",
  "data": {
    "isFriend": true,
    "status": "ACCEPTED",
    "friendshipId": "123456789012345678"
  },
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 8. Remove Friend

**Endpoint:** `DELETE /users/friends/remove`

**Description:** Remove a user from friends list

**Headers:**
```http
Authorization: Bearer <access_token>
Content-Type: application/json
```

**Request Body:**
```json
{
  "userId": "987654321098765432"
}
```

**Validation Rules:**
- `userId`: Required, valid ID format

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "Friend removed successfully",
  "data": {
    "id": "123456789012345678",
    "removedUserId": "987654321098765432",
    "removedAt": "2024-01-15T10:30:00.000Z"
  },
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

---

## User Relations APIs

### 1. Create User Relation

**Endpoint:** `POST /users/relations`

**Description:** Block, ignore, or mute a user

**Headers:**
```http
Authorization: Bearer <access_token>
Content-Type: application/json
```

**Request Body:**
```json
{
  "targetUserId": "987654321098765432",
  "type": "BLOCKED",
  "note": "Spam user"
}
```

**Validation Rules:**
- `targetUserId`: Required, valid ID format
- `type`: Required, must be "BLOCKED", "IGNORED", or "MUTED"
- `note`: Optional, max 500 characters

**Success Response (201):**
```json
{
  "status": "success",
  "code": 201,
  "message": "User relation created successfully",
  "data": {
    "id": "123456789012345678",
    "sourceId": "123456789012345678",
    "targetId": "987654321098765432",
    "type": "BLOCKED",
    "note": "Spam user",
    "createdAt": "2024-01-15T10:30:00.000Z",
    "updatedAt": "2024-01-15T10:30:00.000Z"
  },
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 2. Get User Relations

**Endpoint:** `GET /users/relations`

**Description:** Get all user relations (blocked, ignored, muted users)

**Headers:**
```http
Authorization: Bearer <access_token>
```

**Query Parameters:**
- `type` (optional): Filter by relation type (BLOCKED, IGNORED, MUTED)

**Example:**
```
GET /users/relations?type=BLOCKED
```

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "User relations retrieved successfully",
  "data": [
    {
      "id": "123456789012345678",
      "sourceId": "123456789012345678",
      "targetId": "987654321098765432",
      "type": "BLOCKED",
      "note": "Spam user",
      "createdAt": "2024-01-15T10:30:00.000Z",
      "updatedAt": "2024-01-15T10:30:00.000Z",
      "target": {
        "id": "987654321098765432",
        "username": "jane_doe",
        "globalname": "Jane Doe",
        "avatar": "https://example.com/avatar.jpg",
        "status": "ONLINE"
      }
    }
  ],
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 3. Get Blocked Users

**Endpoint:** `GET /users/relations/blocked`

**Description:** Get all blocked users

**Headers:**
```http
Authorization: Bearer <access_token>
```

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "Blocked users retrieved successfully",
  "data": [
    {
      "id": "123456789012345678",
      "sourceId": "123456789012345678",
      "targetId": "987654321098765432",
      "type": "BLOCKED",
      "note": "Spam user",
      "createdAt": "2024-01-15T10:30:00.000Z",
      "updatedAt": "2024-01-15T10:30:00.000Z",
      "target": {
        "id": "987654321098765432",
        "username": "jane_doe",
        "globalname": "Jane Doe",
        "avatar": "https://example.com/avatar.jpg",
        "status": "ONLINE"
      }
    }
  ],
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 4. Get Ignored Users

**Endpoint:** `GET /users/relations/ignored`

**Description:** Get all ignored users

**Headers:**
```http
Authorization: Bearer <access_token>
```

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "Ignored users retrieved successfully",
  "data": [
    {
      "id": "123456789012345678",
      "sourceId": "123456789012345678",
      "targetId": "987654321098765432",
      "type": "IGNORED",
      "note": "Too many messages",
      "createdAt": "2024-01-15T10:30:00.000Z",
      "updatedAt": "2024-01-15T10:30:00.000Z",
      "target": {
        "id": "987654321098765432",
        "username": "jane_doe",
        "globalname": "Jane Doe",
        "avatar": "https://example.com/avatar.jpg",
        "status": "ONLINE"
      }
    }
  ],
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 5. Get Muted Users

**Endpoint:** `GET /users/relations/muted`

**Description:** Get all muted users

**Headers:**
```http
Authorization: Bearer <access_token>
```

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "Muted users retrieved successfully",
  "data": [
    {
      "id": "123456789012345678",
      "sourceId": "123456789012345678",
      "targetId": "987654321098765432",
      "type": "MUTED",
      "note": "Too many notifications",
      "createdAt": "2024-01-15T10:30:00.000Z",
      "updatedAt": "2024-01-15T10:30:00.000Z",
      "target": {
        "id": "987654321098765432",
        "username": "jane_doe",
        "globalname": "Jane Doe",
        "avatar": "https://example.com/avatar.jpg",
        "status": "ONLINE"
      }
    }
  ],
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 6. Check User Relation

**Endpoint:** `GET /users/relations/check`

**Description:** Check relation status with another user

**Headers:**
```http
Authorization: Bearer <access_token>
```

**Query Parameters:**
- `targetUserId`: Required, ID of the user to check relation with
- `type`: Required, relation type to check (BLOCKED, IGNORED, MUTED)

**Example:**
```
GET /users/relations/check?targetUserId=987654321098765432&type=BLOCKED
```

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "User relation checked successfully",
  "data": {
    "hasRelation": true,
    "type": "BLOCKED",
    "relationId": "123456789012345678",
    "note": "Spam user"
  },
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 7. Update Relation Note

**Endpoint:** `PUT /users/relations/note`

**Description:** Update the note for a user relation

**Headers:**
```http
Authorization: Bearer <access_token>
Content-Type: application/json
```

**Request Body:**
```json
{
  "targetUserId": "987654321098765432",
  "type": "BLOCKED",
  "note": "Updated reason for blocking"
}
```

**Validation Rules:**
- `targetUserId`: Required, valid ID format
- `type`: Required, must be "BLOCKED", "IGNORED", or "MUTED"
- `note`: Required, max 500 characters

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "Relation note updated successfully",
  "data": {
    "id": "123456789012345678",
    "sourceId": "123456789012345678",
    "targetId": "987654321098765432",
    "type": "BLOCKED",
    "note": "Updated reason for blocking",
    "createdAt": "2024-01-15T10:30:00.000Z",
    "updatedAt": "2024-01-15T10:30:00.000Z"
  },
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 8. Remove User Relation

**Endpoint:** `DELETE /users/relations`

**Description:** Remove a user relation (unblock, unignore, unmute)

**Headers:**
```http
Authorization: Bearer <access_token>
Content-Type: application/json
```

**Request Body:**
```json
{
  "targetUserId": "987654321098765432",
  "type": "BLOCKED"
}
```

**Validation Rules:**
- `targetUserId`: Required, valid ID format
- `type`: Required, must be "BLOCKED", "IGNORED", or "MUTED"

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "User relation removed successfully",
  "data": {
    "id": "123456789012345678",
    "removedUserId": "987654321098765432",
    "removedType": "BLOCKED",
    "removedAt": "2024-01-15T10:30:00.000Z"
  },
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

### 9. Get Relation Stats

**Endpoint:** `GET /users/relations/stats`

**Description:** Get statistics about user relations

**Headers:**
```http
Authorization: Bearer <access_token>
```

**Success Response (200):**
```json
{
  "status": "success",
  "code": 200,
  "message": "Relation stats retrieved successfully",
  "data": {
    "blocked": 5,
    "ignored": 3,
    "muted": 2,
    "total": 10
  },
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

---

## Error Handling

### HTTP Status Codes

| Code | Description |
|------|-------------|
| 200 | Success |
| 201 | Created |
| 400 | Bad Request |
| 401 | Unauthorized |
| 403 | Forbidden |
| 404 | Not Found |
| 409 | Conflict |
| 422 | Validation Error |
| 500 | Internal Server Error |

### Common Error Messages

#### Authentication Errors
- `"Forbidden resource. No token provided"` - Missing Authorization header
- `"Forbidden resource. Invalid token"` - Invalid or expired token
- `"Forbidden resource. User not found or invalid"` - User not found
- `"Invalid credentials"` - Wrong email/password

#### Validation Errors
- `"Username must be at least 3 characters long"`
- `"Username can only contain letters, numbers, underscores, and dots"`
- `"Username 'admin' is reserved and cannot be used"`
- `"Email must be a valid email address"`
- `"Password must be a strong password"`
- `"User ID must be a valid ID (16-19 digits)"`

#### Business Logic Errors
- `"Username already exists"`
- `"Email already exists"`
- `"User not found"`
- `"Friendship request already exists"`
- `"Cannot send friend request to yourself"`
- `"User is already blocked"`

---

## Frontend Integration Guide

### 1. Authentication Flow

```javascript
// Register user
const registerUser = async (userData) => {
  try {
    const response = await fetch('http://localhost:3000/api/v1/auth/register', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        username: userData.username,
        email: userData.email,
        password: userData.password,
        birthdate: userData.birthdate, // Format: YYYY-MM-DD
      }),
    });

    const result = await response.json();
    
    if (result.status === 'success') {
      // Store tokens
      localStorage.setItem('accessToken', result.data.accessToken);
      localStorage.setItem('refreshToken', result.data.refreshToken);
      return result.data.user;
    } else {
      throw new Error(result.message);
    }
  } catch (error) {
    console.error('Registration failed:', error);
    throw error;
  }
};

// Login user
const loginUser = async (email, password) => {
  try {
    const response = await fetch('http://localhost:3000/api/v1/auth/login', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ email, password }),
    });

    const result = await response.json();
    
    if (result.status === 'success') {
      // Store tokens
      localStorage.setItem('accessToken', result.data.accessToken);
      localStorage.setItem('refreshToken', result.data.refreshToken);
      return result.data;
    } else {
      throw new Error(result.message);
    }
  } catch (error) {
    console.error('Login failed:', error);
    throw error;
  }
};
```

### 2. API Client Setup

```javascript
class DiscordAPI {
  constructor(baseURL = 'http://localhost:3000/api/v1') {
    this.baseURL = baseURL;
  }

  // Get authorization header
  getAuthHeader() {
    const token = localStorage.getItem('accessToken');
    return token ? `Bearer ${token}` : null;
  }

  // Make authenticated request
  async makeRequest(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const authHeader = this.getAuthHeader();

    const config = {
      headers: {
        'Content-Type': 'application/json',
        ...(authHeader && { Authorization: authHeader }),
        ...options.headers,
      },
      ...options,
    };

    try {
      const response = await fetch(url, config);
      const result = await response.json();

      if (result.status === 'success') {
        return result.data;
      } else {
        throw new Error(result.message);
      }
    } catch (error) {
      console.error('API request failed:', error);
      throw error;
    }
  }

  // User Profile Methods
  async getProfile() {
    return this.makeRequest('/users/profile');
  }

  async updatePassword(currentPassword, newPassword) {
    return this.makeRequest('/users/profile/password', {
      method: 'PUT',
      body: JSON.stringify({ currentPassword, newPassword }),
    });
  }

  async updateglobalname(globalname) {
    return this.makeRequest('/users/profile/global-name', {
      method: 'PUT',
      body: JSON.stringify({ globalname }),
    });
  }

  async updateCustomStatus(customStatus) {
    return this.makeRequest('/users/profile/custom-status', {
      method: 'PUT',
      body: JSON.stringify({ customStatus }),
    });
  }

  async updateUsername(username) {
    return this.makeRequest('/users/profile/username', {
      method: 'PUT',
      body: JSON.stringify({ username }),
    });
  }

  // Friendship Methods
  async sendFriendRequest(username) {
    return this.makeRequest('/users/friends/request', {
      method: 'POST',
      body: JSON.stringify({ username }),
    });
  }

  async respondToFriendRequest(friendshipId, status) {
    return this.makeRequest('/users/friends/respond', {
      method: 'PUT',
      body: JSON.stringify({ friendshipId, status }),
    });
  }

  async getFriends(status = null) {
    const query = status ? `?status=${status}` : '';
    return this.makeRequest(`/users/friends${query}`);
  }

  async getIncomingRequests() {
    return this.makeRequest('/users/friends/requests/incoming');
  }

  async getOutgoingRequests() {
    return this.makeRequest('/users/friends/requests/outgoing');
  }

  async getMutualFriends(userId) {
    return this.makeRequest(`/users/friends/mutual/${userId}`);
  }

  async checkFriendship(userId) {
    return this.makeRequest(`/users/friends/check/${userId}`);
  }

  async removeFriend(userId) {
    return this.makeRequest('/users/friends/remove', {
      method: 'DELETE',
      body: JSON.stringify({ userId }),
    });
  }

  // User Relations Methods
  async createUserRelation(targetUserId, type, note = null) {
    return this.makeRequest('/users/relations', {
      method: 'POST',
      body: JSON.stringify({ targetUserId, type, note }),
    });
  }

  async getUserRelations(type = null) {
    const query = type ? `?type=${type}` : '';
    return this.makeRequest(`/users/relations${query}`);
  }

  async getBlockedUsers() {
    return this.makeRequest('/users/relations/blocked');
  }

  async getIgnoredUsers() {
    return this.makeRequest('/users/relations/ignored');
  }

  async getMutedUsers() {
    return this.makeRequest('/users/relations/muted');
  }

  async checkUserRelation(targetUserId, type) {
    return this.makeRequest(`/users/relations/check?targetUserId=${targetUserId}&type=${type}`);
  }

  async updateRelationNote(targetUserId, type, note) {
    return this.makeRequest('/users/relations/note', {
      method: 'PUT',
      body: JSON.stringify({ targetUserId, type, note }),
    });
  }

  async removeUserRelation(targetUserId, type) {
    return this.makeRequest('/users/relations', {
      method: 'DELETE',
      body: JSON.stringify({ targetUserId, type }),
    });
  }

  async getRelationStats() {
    return this.makeRequest('/users/relations/stats');
  }
}

// Usage
const api = new DiscordAPI();

// Example usage
try {
  const profile = await api.getProfile();
  console.log('User profile:', profile);

  const friends = await api.getFriends();
  console.log('Friends list:', friends);

  const blockedUsers = await api.getBlockedUsers();
  console.log('Blocked users:', blockedUsers);
} catch (error) {
  console.error('Error:', error.message);
}
```

### 3. Form Validation (Frontend)

```javascript
// Username validation
const validateUsername = (username) => {
  const errors = [];
  
  if (!username) {
    errors.push('Username is required');
  } else if (username.length < 3) {
    errors.push('Username must be at least 3 characters long');
  } else if (username.length > 32) {
    errors.push('Username must not exceed 32 characters');
  } else if (!/^[a-zA-Z0-9._]+$/.test(username)) {
    errors.push('Username can only contain letters, numbers, underscores, and dots');
  } else if (['admin', 'support', 'discord', 'system'].includes(username.toLowerCase())) {
    errors.push(`Username '${username}' is reserved and cannot be used`);
  }
  
  return errors;
};

// Email validation
const validateEmail = (email) => {
  const errors = [];
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  
  if (!email) {
    errors.push('Email is required');
  } else if (!emailRegex.test(email)) {
    errors.push('Email must be a valid email address');
  }
  
  return errors;
};

// Password validation
const validatePassword = (password) => {
  const errors = [];
  
  if (!password) {
    errors.push('Password is required');
  } else if (password.length < 8) {
    errors.push('Password must be at least 8 characters long');
  } else if (!/(?=.*[a-z])/.test(password)) {
    errors.push('Password must contain at least one lowercase letter');
  } else if (!/(?=.*[A-Z])/.test(password)) {
    errors.push('Password must contain at least one uppercase letter');
  } else if (!/(?=.*\d)/.test(password)) {
    errors.push('Password must contain at least one number');
  } else if (!/(?=.*[@$!%*?&])/.test(password)) {
    errors.push('Password must contain at least one special character');
  }
  
  return errors;
};

// User ID validation
const validateUserId = (userId) => {
  const errors = [];
  
  if (!userId) {
    errors.push('User ID is required');
  } else if (!/^\d{16,19}$/.test(userId)) {
    errors.push('User ID must be a valid ID (16-19 digits)');
  }
  
  return errors;
};

// Date validation
const validateBirthdate = (birthdate) => {
  const errors = [];
  
  if (!birthdate) {
    errors.push('Birthdate is required');
  } else {
    const date = new Date(birthdate);
    const today = new Date();
    
    if (isNaN(date.getTime())) {
      errors.push('Birthdate must be a valid date');
    } else if (date >= today) {
      errors.push('Birthdate must be in the past');
    } else {
      const age = today.getFullYear() - date.getFullYear();
      if (age < 13) {
        errors.push('You must be at least 13 years old');
      }
    }
  }
  
  return errors;
};
```

### 4. Error Handling

```javascript
const handleApiError = (error) => {
  if (error.response) {
    // Server responded with error status
    const { status, data } = error.response;
    
    switch (status) {
      case 401:
        // Unauthorized - redirect to login
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        window.location.href = '/login';
        break;
      case 422:
        // Validation errors
        if (data.errors) {
          data.errors.forEach(err => {
            console.error(`${err.field}: ${err.message}`);
          });
        }
        break;
      case 409:
        // Conflict - show specific message
        alert(data.message);
        break;
      default:
        alert(data.message || 'An error occurred');
    }
  } else if (error.request) {
    // Network error
    alert('Network error. Please check your connection.');
  } else {
    // Other error
    alert(error.message || 'An unexpected error occurred');
  }
};
```

### 5. React Hook Example

```javascript
import { useState, useEffect } from 'react';

const useDiscordAPI = () => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const api = new DiscordAPI();

  const login = async (email, password) => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await api.loginUser(email, password);
      const profile = await api.getProfile();
      setUser(profile);
      return result;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const logout = () => {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
    setUser(null);
  };

  useEffect(() => {
    // Check if user is logged in on app start
    const token = localStorage.getItem('accessToken');
    if (token) {
      api.getProfile()
        .then(profile => setUser(profile))
        .catch(() => logout());
    }
  }, []);

  return {
    user,
    loading,
    error,
    login,
    logout,
    api,
  };
};

export default useDiscordAPI;
```

---

## Summary

This Discord Clone API provides:

âœ… **Complete Authentication System**
- User registration with validation
- JWT-based authentication
- Password management

âœ… **User Profile Management**
- Profile information retrieval
- Username, global name, custom status updates
- Password changes

âœ… **Friendship System**
- Send/accept/reject friend requests
- Friends list management
- Mutual friends discovery
- Friendship status checking

âœ… **User Relations**
- Block, ignore, mute users
- Relation management with notes
- Statistics and filtering

âœ… **Comprehensive Validation**
- Username format validation
- Email validation
- Password strength requirements
- User ID format validation
- Date validation

âœ… **Frontend Integration Ready**
- Complete API client class
- Form validation functions
- Error handling patterns
- React hooks example

The API is designed to be simple, consistent, and easy to integrate with any frontend framework. All endpoints follow RESTful conventions and return consistent response formats.


============================================================
FILE: docs/BACKEND_ARCHITECTURE.md
============================================================
# Backend Architecture Documentation

## ğŸ“‹ Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø© (Overview)

Discord Clone Backend Ù…Ø¨Ù†ÙŠ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù…:
- **NestJS** - Framework
- **Prisma** - ORM
- **PostgreSQL** - Database
- **Redis** - Caching & Presence
- **Socket.IO** - WebSocket

---

## ğŸ—ï¸ System Architecture

### High-Level Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Frontend   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â”€â–º REST API (HTTP)
       â”‚   â””â”€â–º NestJS Controllers
       â”‚       â””â”€â–º Services
       â”‚           â”œâ”€â–º Database (PostgreSQL)
       â”‚           â””â”€â–º Redis (Presence)
       â”‚
       â””â”€â”€â–º WebSocket (Socket.IO)
           â””â”€â–º Gateway
               â””â”€â–º UnifiedPresenceService
                   â””â”€â–º Redis (Real-time)
```

---

## ğŸ“‚ Project Structure

```
src/
â”œâ”€â”€ common/
â”‚   â”œâ”€â”€ bootstrap/          # App initialization
â”‚   â”œâ”€â”€ config/             # Configuration files
â”‚   â”œâ”€â”€ database/           # Prisma service & repositories
â”‚   â”œâ”€â”€ decorators/         # Custom decorators
â”‚   â”œâ”€â”€ dto/                # Shared DTOs
â”‚   â”œâ”€â”€ filters/            # Exception filters
â”‚   â”œâ”€â”€ Global/             # Global utilities
â”‚   â”‚   â”œâ”€â”€ cache/          # Redis cache services
â”‚   â”‚   â”œâ”€â”€ security/       # JWT, hashing, encryption
â”‚   â”‚   â””â”€â”€ validators/     # Custom validators
â”‚   â”œâ”€â”€ guards/             # Auth guards
â”‚   â”œâ”€â”€ interceptors/       # Response interceptors
â”‚   â””â”€â”€ utils/              # Helper functions
â”‚
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ auth/               # Authentication
â”‚   â”‚   â”œâ”€â”€ auth.controller.ts
â”‚   â”‚   â”œâ”€â”€ auth.service.ts
â”‚   â”‚   â””â”€â”€ dto/
â”‚   â”‚
â”‚   â”œâ”€â”€ users/              # User management
â”‚   â”‚   â””â”€â”€ v1/
â”‚   â”‚       â”œâ”€â”€ users.controller.ts
â”‚   â”‚       â”œâ”€â”€ users.service.ts
â”‚   â”‚       â”œâ”€â”€ dto/
â”‚   â”‚       â””â”€â”€ decorators/
â”‚   â”‚
â”‚   â””â”€â”€ websocket/          # WebSocket Gateway
â”‚       â””â”€â”€ User/
â”‚           â”œâ”€â”€ websocket.gateway.ts
â”‚           â”œâ”€â”€ auth/       # WebSocket authentication
â”‚           â”œâ”€â”€ services/
â”‚           â”‚   â””â”€â”€ unified-presence.service.ts  # â­ Core presence logic
â”‚           â”œâ”€â”€ friends/    # Friend notifications
â”‚           â””â”€â”€ presence/   # Presence broadcasting
â”‚
â””â”€â”€ main.ts                 # Application entry point
```

---

## ğŸ”´ Presence System Architecture

### Redis-Based Presence (Discord-like)

```
User Connects
    â”‚
    â”œâ”€â–º WebSocket Gateway
    â”‚       â”‚
    â”‚       â”œâ”€â–º Authenticate (JWT)
    â”‚       â”‚
    â”‚       â””â”€â–º UnifiedPresenceService.markOnline()
    â”‚               â”‚
    â”‚               â”œâ”€â–º Redis: presence:online:{userId} = 'true'
    â”‚               â”œâ”€â–º Redis: presence:sockets:{userId} = Set[socketId]
    â”‚               â””â”€â–º Redis: presence:{userId}:{socketId} = Metadata
    â”‚
    â””â”€â–º Update Redis only (NO database update!)
```

### Key Components

#### 1. UnifiedPresenceService
**Location:** `src/modules/websocket/User/services/unified-presence.service.ts`

**Responsibilities:**
- Connection tracking (online/offline)
- Display status management (ONLINE, IDLE, DND, Invisible)
- Redis operations
- WebSocket event handling

**Key Methods:**
```typescript
markOnline(userId, socketId, metadata)     // Mark user online
markOffline(userId, socketId)               // Mark user offline
isOnline(userId)                            // Check if online
getPresenceStatus(userId)                   // Get complete status
getDisplayStatus(userId)                    // Get display status
setDisplayStatus(userId, status)             // Set display status
```

#### 2. Redis Keys Structure

```redis
# Connection Tracking (TTL: 90s)
presence:{userId}:{socketId}        â†’ Hash {device, connectedAt, ip, lastPing}
presence:sockets:{userId}            â†’ Set of socketIds
presence:online:{userId}             â†’ 'true' | (deleted)

# Display Status (TTL: 24h)
display:status:{userId}              â†’ 'ONLINE' | 'IDLE' | 'DND' | 'Invisible'
```

#### 3. Database vs Redis

| Data | Storage | Purpose | Volatile? |
|------|---------|---------|-----------|
| User Info | PostgreSQL | Permanent data | âŒ No |
| **Presence Status** | **Redis** | **Real-time connection** | âœ… **Yes** |
| Display Status | Redis | User's chosen status | âœ… Yes |
| Friendships | PostgreSQL | Permanent relationships | âŒ No |
| Custom Status | PostgreSQL | User's status text/emoji | âŒ No |

---

## ğŸ” Authentication Flow

### REST API Authentication

```
1. User sends credentials
   â†“
2. AuthController receives request
   â†“
3. AuthService validates
   â†“
4. Returns JWT tokens (access + refresh)
   â†“
5. Client stores tokens
   â†“
6. Client sends token in Authorization header
   â†“
7. AuthGuard validates token
   â†“
8. Extracts user from token
   â†“
9. Attaches user to request
```

### WebSocket Authentication

```
1. Client connects with JWT in auth
   â†“
2. Gateway receives connection
   â†“
3. AuthService.authenticateClient()
   â†“
4. Validates JWT token
   â†“
5. Extracts userId
   â†“
6. Stores user in socket.data
   â†“
7. Allows connection or disconnects
```

---

## ğŸ“Š Data Flow Examples

### Example 1: User Connects

```
Client â†’ WebSocket Connect (JWT)
    â†“
Gateway.handleConnection()
    â†“
ConnectionHandlerService.handleConnection()
    â†“
AuthService.authenticateClient()
    â†“
UnifiedPresenceService.markOnline()
    â†“
Redis Operations:
    - presence:online:{userId} = 'true'
    - presence:sockets:{userId}.add(socketId)
    - presence:{userId}:{socketId} = metadata
    â†“
Socket joins: user:{userId}
    â†“
Emit 'connected' event to client
```

### Example 2: Get User Profile

```
Client â†’ GET /users/@me (JWT)
    â†“
UsersController.getProfile()
    â†“
UsersService.getProfile()
    â†“
UnifiedPresenceService.getPresenceStatus()
    â”œâ”€â–º Redis: presence:online:{userId}
    â””â”€â–º Redis: display:status:{userId}
    â†“
Returns:
    {
      isOnline: true,      // From Redis
      status: "IDLE",      // From Redis
      ...user data...
    }
```

### Example 3: Update Presence Status

```
Client â†’ PUT /users/@me/update/presenceStatus (JWT)
    â†“
UsersController.updatePresenceStatus()
    â†“
UsersService.updatePresenceStatus()
    â†“
PresenceRepository.updateStatus()      // Update DB (for display)
    â†“
UnifiedPresenceService.setDisplayStatus()  // Update Redis
    â†“
BroadcasterService broadcasts to friends
    â†“
Friends receive 'presence:updated' event
```

---

## ğŸ—„ï¸ Database Schema

### Key Tables

#### User
```prisma
model User {
  id             BigInt    @id
  username       String    @unique
  globalname     String?
  email          String?   @unique
  password       String
  isOnline       Boolean?  @default(false)  // âš ï¸ Deprecated - Use Redis
  ...
}
```

**Note:** `isOnline` Ù…ÙˆØ¬ÙˆØ¯ Ù„ÙƒÙ† **Ù„Ø§ ÙŠÙØ³ØªØ®Ø¯Ù…** Ù„Ù„Ù€ presence. Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„ÙØ¹Ù„ÙŠØ© Ù…Ù† Redis.

#### Presence
```prisma
model Presence {
  id          BigInt      @id
  userId      BigInt      @unique
  status      UserStatus? // Display status (optional)
  expiresAt   DateTime?
  ...
}
```

**Note:** `status` Ù‡Ù†Ø§ Ù„Ù„Ù€ display status ÙÙ‚Ø·ØŒ ÙˆÙ„ÙŠØ³ connection status.

#### Friendship
```prisma
model Friendship {
  id        BigInt           @id
  user1Id   BigInt
  user2Id   BigInt
  status    FriendshipStatus
  ...
}
```

---

## ğŸ”„ Services & Repositories

### Services Layer

| Service | Location | Purpose |
|---------|----------|---------|
| `AuthService` | `modules/auth/` | Authentication & JWT |
| `UsersService` | `modules/users/v1/` | User profile & friends |
| `UnifiedPresenceService` | `modules/websocket/User/services/` | **Presence management** |
| `FriendsCacheService` | `common/Global/cache/User/` | Friends caching |
| `BroadcasterService` | `modules/websocket/User/presence/` | WebSocket broadcasting |

### Repositories Layer

| Repository | Location | Purpose |
|------------|----------|---------|
| `UserRepository` | `common/database/repositories/User/` | User CRUD |
| `PresenceRepository` | `common/database/repositories/User/` | Presence CRUD |
| `FriendshipRepository` | `common/database/repositories/User/` | Friendships |
| `UserRelationRepository` | `common/database/repositories/User/` | Blocks/Ignores/Mutes |

---

## ğŸ”Œ WebSocket Gateway

### Gateway Structure

```
WebSocketGatewayService
    â”‚
    â”œâ”€â–º ConnectionHandlerService
    â”‚       â”œâ”€â–º handleConnection()
    â”‚       â””â”€â–º handleDisconnect()
    â”‚
    â”œâ”€â–º UnifiedPresenceService
    â”‚       â”œâ”€â–º markOnline()
    â”‚       â”œâ”€â–º markOffline()
    â”‚       â””â”€â–º getPresenceStatus()
    â”‚
    â”œâ”€â–º BroadcasterService
    â”‚       â””â”€â–º Broadcast to friends
    â”‚
    â””â”€â–º FriendsService
            â””â”€â–º Friend notifications
```

### Events Flow

```
Client Event              â†’  Gateway Handler          â†’  Action
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
connect                  â†’  handleConnection()        â†’  markOnline()
disconnect               â†’  handleDisconnect()        â†’  markOffline()
status:get              â†’  handleGetStatus()          â†’  getPresenceStatus()
status:update           â†’  handleStatusUpdate()      â†’  setDisplayStatus()
```

---

## ğŸ¯ Key Design Decisions

### 1. Why Redis for Presence?

âœ… **Volatile Data**: Connection status changes frequently  
âœ… **Performance**: Redis is faster than DB for reads  
âœ… **Real-time**: Reflects actual state, not stale data  
âœ… **Auto-cleanup**: TTL ensures accuracy after restart  
âœ… **Scalability**: Works across multiple servers  

### 2. Why Not Database?

âŒ **Stale Data**: DB updates might not reflect actual state  
âŒ **Performance**: Slower for frequent reads  
âŒ **Restart Issues**: Users might appear online when offline  
âŒ **Scalability**: Harder to sync across servers  

### 3. Separation of Concerns

- **Connection Status** â†’ Redis (volatile, real-time)
- **Display Status** â†’ Redis (user choice)
- **User Data** â†’ PostgreSQL (permanent)
- **Friendships** â†’ PostgreSQL (relationships)

---

## ğŸ”§ Configuration

### Environment Variables

```env
# Database
DATABASE_URL=postgresql://user:password@localhost:5432/discord_clone

# Redis (Presence)
CACHE_HOST=localhost
CACHE_PORT=6379
CACHE_PASS=

# JWT
JWT_SECRET_ACCESS=your_secret_key
JWT_EXPIRES_IN=7d

# Server
PORT=3000
```

### Redis TTL Configuration

```typescript
// In UnifiedPresenceService
PRESENCE_TTL = 90;              // Connection tracking (90 seconds)
DISPLAY_STATUS_TTL = 86400;     // Display status (24 hours)
```

**Why 90 seconds?**
- Allows ping/pong to refresh TTL
- Auto-cleanup dead connections
- Balance between accuracy and performance

---

## ğŸ“ˆ Performance Considerations

### Redis Optimization

1. **Keys Pattern**: Use consistent prefixes (`presence:*`, `display:*`)
2. **TTL**: Auto-expire unused keys
3. **Pipeline**: Batch Redis operations when possible
4. **Connection Pool**: Reuse Redis connections

### Database Optimization

1. **Indexes**: Username, email, user relationships
2. **Pagination**: Use for friends lists
3. **Caching**: Cache friends list in Redis

---

## ğŸ” Debugging & Logging

### Logs Locations

- **Application Logs**: Console output
- **Redis Logs**: Check Redis connection in UnifiedPresenceService
- **WebSocket Logs**: Connection/disconnection events

### Common Debug Scenarios

1. **User appears offline when online**
   - Check Redis connection
   - Verify `presence:online:{userId}` exists
   - Check WebSocket connection

2. **Status not updating**
   - Verify Redis key `display:status:{userId}`
   - Check WebSocket events
   - Review service logs

---

## ğŸš€ Deployment Considerations

### Production Setup

1. **Redis**: Use Redis Cluster for high availability
2. **Database**: PostgreSQL with connection pooling
3. **WebSocket**: Load balancer with sticky sessions
4. **Monitoring**: Monitor Redis memory usage

### Multi-Instance Deployment

```
Load Balancer
    â”œâ”€â–º Server 1 â†’ Redis Cluster
    â”œâ”€â–º Server 2 â†’ Redis Cluster
    â””â”€â–º Server 3 â†’ Redis Cluster
```

**All servers share Redis** â†’ Presence syncs across all instances.

---

## ğŸ“š Related Documentation

- [Redis Presence System](./REDIS_PRESENCE_SYSTEM.md) - ØªÙØ§ØµÙŠÙ„ Presence
- [Quick Start Guide](./QUICK_START_GUIDE.md) - Ø¯Ù„ÙŠÙ„ Ø³Ø±ÙŠØ¹
- [API Documentation](./API_DOCUMENTATION.md) - REST APIs
- [Socket.IO Guide](./SOCKET_IO_GUIDE.md) - WebSocket Events

---

## ğŸ”— External Resources

- [NestJS Documentation](https://docs.nestjs.com)
- [Prisma Documentation](https://www.prisma.io/docs)
- [Redis Documentation](https://redis.io/docs)
- [Socket.IO Documentation](https://socket.io/docs)

---

**Last Updated:** 2024-01-15  
**Version:** 1.0.0



============================================================
FILE: docs/QUICK_START_GUIDE.md
============================================================
# Quick Start Guide - Discord Clone API

## ğŸš€ Ø§Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ø³Ø±ÙŠØ¹

Ø¯Ù„ÙŠÙ„ Ø³Ø±ÙŠØ¹ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Discord Clone API Ø¨Ø¯ÙˆÙ† ØªØ¹Ù‚ÙŠØ¯.

---

## ğŸ“‹ Ø§Ù„Ù…Ø­ØªÙˆÙŠØ§Øª

1. [Authentication](#authentication)
2. [Profile Management](#profile-management)
3. [Friends System](#friends-system)
4. [User Relations](#user-relations)
5. [Presence System](#presence-system)
6. [WebSocket](#websocket)

---

## ğŸ” Authentication

### 1. Register (Ø§Ù„ØªØ³Ø¬ÙŠÙ„)

```http
POST /api/v1/auth/register
Content-Type: application/json

{
  "username": "john_doe",
  "email": "john@example.com",
  "password": "Password123!",
  "birthdate": "2000-01-01"
}
```

**Response:**
```json
{
  "status": "success",
  "code": 201,
  "data": {
    "user": { ... },
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "..."
  }
}
```

### 2. Login (ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„)

```http
POST /api/v1/auth/login
Content-Type: application/json

{
  "email": "john@example.com",
  "password": "Password123!"
}
```

**Response:** Ù†ÙØ³ Register (accessToken + refreshToken)

---

## ğŸ‘¤ Profile Management

### Get Profile (Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Profile)

```http
GET /api/v1/users/@me
Authorization: Bearer <access_token>
```

**Response:**
```json
{
  "status": "success",
  "data": {
    "id": "5280662395293696",
    "username": "john_doe",
    "globalname": "John Doe",
    "email": "john@example.com",
    "isOnline": true,        // âœ… Ù…Ù† Redis (real-time)
    "status": "ONLINE",       // âœ… Display Status
    "customStatus": "Working..."
  }
}
```

### Update Global Name

```http
PUT /api/v1/users/@me/update/globalname
Authorization: Bearer <token>
Content-Type: application/json

{
  "globalname": "John Doe Updated"
}
```

### Update Username

```http
PUT /api/v1/users/@me/update/username
Authorization: Bearer <token>
Content-Type: application/json

{
  "username": "john_doe_2024"
}
```

### Update Password

```http
PUT /api/v1/users/@me/update/password
Authorization: Bearer <token>
Content-Type: application/json

{
  "currentPassword": "OldPassword123!",
  "newPassword": "NewPassword123!"
}
```

### Update Custom Status

```http
PUT /api/v1/users/@me/update/customstatus
Authorization: Bearer <token>
Content-Type: application/json

{
  "text": "Playing Minecraft ğŸ®",
  "emoji": "ğŸ®"
}
```

### Update Presence Status

```http
PUT /api/v1/users/@me/update/presenceStatus
Authorization: Bearer <token>
Content-Type: application/json

{
  "status": "IDLE"  // ONLINE | IDLE | DND | Invisible
}
```

---

## ğŸ‘¥ Friends System

### Send Friend Request

```http
POST /api/v1/users/friends/request
Authorization: Bearer <token>
Content-Type: application/json

{
  "username": "jane_doe"  // OR "userId": "123456789012345678"
}
```

### Respond to Friend Request

```http
PUT /api/v1/users/friends/respond
Authorization: Bearer <token>
Content-Type: application/json

{
  "friendshipId": "123456789012345678",
  "status": "ACCEPTED"  // or "REJECTED"
}
```

### Get Friends List

```http
GET /api/v1/users/friends
Authorization: Bearer <token>
```

**Query Parameters:**
- `status` (optional): `PENDING` | `ACCEPTED`
- `page` (optional): Page number
- `limit` (optional): Items per page

**Response:**
```json
{
  "status": "success",
  "data": {
    "friends": [
      {
        "id": "987654321098765432",
        "username": "jane_doe",
        "status": "ONLINE",           // âœ… Real-time from Redis
        "customStatus": "Coding...",
        "friendshipId": "...",
        "createdAt": "..."
      }
    ],
    "pagination": {
      "page": 1,
      "limit": 20,
      "total": 10
    }
  }
}
```

### Get Incoming Requests

```http
GET /api/v1/users/friends/requests/incoming
Authorization: Bearer <token>
```

### Get Outgoing Requests

```http
GET /api/v1/users/friends/requests/outgoing
Authorization: Bearer <token>
```

### Cancel Friend Request

```http
DELETE /api/v1/users/friends/cancel
Authorization: Bearer <token>
Content-Type: application/json

{
  "friendshipId": "123456789012345678"
}
```

### Remove Friend

```http
DELETE /api/v1/users/friends/remove
Authorization: Bearer <token>
Content-Type: application/json

{
  "userId": "987654321098765432"
}
```

### Get Mutual Friends

```http
GET /api/v1/users/friends/mutual/{userId}
Authorization: Bearer <token>
```

### Check Friendship

```http
GET /api/v1/users/friends/check/{userId}
Authorization: Bearer <token>
```

**Response:**
```json
{
  "areFriends": true,
  "hasPendingRequest": false
}
```

---

## ğŸš« User Relations

### Block User

```http
POST /api/v1/users/relations
Authorization: Bearer <token>
Content-Type: application/json

{
  "targetUserId": "987654321098765432",
  "type": "BLOCKED",
  "note": "Spam user"  // optional
}
```

### Ignore User

```http
POST /api/v1/users/relations
Authorization: Bearer <token>
Content-Type: application/json

{
  "targetUserId": "987654321098765432",
  "type": "IGNORED",
  "note": "Too many messages"
}
```

### Mute User

```http
POST /api/v1/users/relations
Authorization: Bearer <token>
Content-Type: application/json

{
  "targetUserId": "987654321098765432",
  "type": "MUTED",
  "note": "Too many notifications"
}
```

### Get Blocked Users

```http
GET /api/v1/users/relations/blocked
Authorization: Bearer <token>
```

### Get Ignored Users

```http
GET /api/v1/users/relations/ignored
Authorization: Bearer <token>
```

### Get Muted Users

```http
GET /api/v1/users/relations/muted
Authorization: Bearer <token>
```

### Get All Relations

```http
GET /api/v1/users/relations
Authorization: Bearer <token>
```

**Query Parameters:**
- `type` (optional): `BLOCKED` | `IGNORED` | `MUTED`

### Remove Relation

```http
DELETE /api/v1/users/relations
Authorization: Bearer <token>
Content-Type: application/json

{
  "targetUserId": "987654321098765432",
  "type": "BLOCKED"
}
```

### Update Relation Note

```http
PUT /api/v1/users/relations/note
Authorization: Bearer <token>
Content-Type: application/json

{
  "targetUserId": "987654321098765432",
  "type": "BLOCKED",
  "note": "Updated reason"
}
```

### Check Relation

```http
GET /api/v1/users/relations/check?targetUserId={userId}&type=BLOCKED
Authorization: Bearer <token>
```

### Get Relation Stats

```http
GET /api/v1/users/relations/stats
Authorization: Bearer <token>
```

**Response:**
```json
{
  "blocked": 5,
  "ignored": 3,
  "muted": 2,
  "total": 10
}
```

---

## ğŸ”´ Presence System

### Status Types

- **ONLINE** - Ù…ØªØµÙ„ ÙˆÙ…ØªØ§Ø­
- **IDLE** - Ù…ØªØµÙ„ Ù„ÙƒÙ† ØºÙŠØ± Ù†Ø´Ø·
- **DND** - Ù„Ø§ ØªØ²Ø¹Ø¬Ù†ÙŠ (Do Not Disturb)
- **Invisible** - ÙŠØ¸Ù‡Ø± offline (Ù„ÙƒÙ† Ù…ØªØµÙ„ ÙØ¹Ù„ÙŠØ§Ù‹)

### Update Status

```http
PUT /api/v1/users/@me/update/presenceStatus
Authorization: Bearer <token>
Content-Type: application/json

{
  "status": "IDLE"
}
```

### Get Status from Profile

```http
GET /api/v1/users/@me
Authorization: Bearer <token>
```

**Response includes:**
```json
{
  "isOnline": true,    // âœ… Connection status (from Redis)
  "status": "IDLE"     // âœ… Display status (from Redis)
}
```

---

## ğŸ”Œ WebSocket

### Connect

```javascript
import io from 'socket.io-client';

const socket = io('http://localhost:3000', {
  auth: { token: 'your_jwt_token' }
});
```

### Events

#### Connection Confirmed
```javascript
socket.on('connected', (data) => {
  console.log('Connected:', data.userId);
});
```

#### Get Status
```javascript
socket.emit('status:get');

socket.on('status:current', (data) => {
  console.log('Connection:', data.connectionStatus);
  console.log('Display:', data.displayStatus);
  console.log('Actual:', data.actualStatus);
});
```

#### Friend Status Updates
```javascript
socket.on('presence:updated', (data) => {
  console.log(`${data.username} is now ${data.status}`);
});
```

---

## ğŸ“ Example: Complete Flow

```javascript
// 1. Login
const loginRes = await fetch('/api/v1/auth/login', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ email: 'john@example.com', password: 'Password123!' })
});
const { data } = await loginRes.json();
const token = data.accessToken;

// 2. Get Profile
const profileRes = await fetch('/api/v1/users/@me', {
  headers: { 'Authorization': `Bearer ${token}` }
});
const profile = await profileRes.json();
console.log('Is Online:', profile.data.isOnline); // âœ… From Redis

// 3. Connect WebSocket
const socket = io('http://localhost:3000', {
  auth: { token }
});

socket.on('connected', () => {
  console.log('âœ… Connected!');
});

// 4. Update Status
await fetch('/api/v1/users/@me/update/presenceStatus', {
  method: 'PUT',
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ status: 'IDLE' })
});

// 5. Send Friend Request
await fetch('/api/v1/users/friends/request', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ username: 'jane_doe' })
});
```

---

## ğŸ”‘ Important Notes

### âœ… Always Use

- âœ… `Authorization: Bearer <token>` header for protected endpoints
- âœ… `isOnline` from API response (not from database)
- âœ… WebSocket for real-time updates
- âœ… REST API for status updates

### âŒ Don't Use

- âŒ Database `isOnline` field directly
- âŒ Hardcoded user IDs (use usernames when possible)
- âŒ Old WebSocket events (use REST API instead)

---

## ğŸ“š More Documentation

- [Redis Presence System](./REDIS_PRESENCE_SYSTEM.md) - ØªÙØ§ØµÙŠÙ„ Ù†Ø¸Ø§Ù… Presence
- [API Documentation](./API_DOCUMENTATION.md) - ØªÙØ§ØµÙŠÙ„ ÙƒØ§Ù…Ù„Ø© Ù„Ù„Ù€ APIs
- [Socket.IO Guide](./SOCKET_IO_GUIDE.md) - WebSocket Events Ø§Ù„ÙƒØ§Ù…Ù„Ø©

---

**Base URL:** `http://localhost:3000/api/v1`  
**WebSocket URL:** `http://localhost:3000`

---

**Last Updated:** 2024-01-15



============================================================
FILE: docs/README.md
============================================================
# Documentation Index

## ğŸ“š Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªÙˆØ«ÙŠÙ‚ Ø§Ù„ÙƒØ§Ù…Ù„Ø©

---

## ğŸš€ Ù„Ù„Ù…Ø¨ØªØ¯Ø¦ÙŠÙ† (Beginners)

### [Quick Start Guide](./QUICK_START_GUIDE.md) â­
**Ø§Ø¨Ø¯Ø£ Ù…Ù† Ù‡Ù†Ø§!**  
Ø¯Ù„ÙŠÙ„ Ø³Ø±ÙŠØ¹ ÙˆØ¨Ø³ÙŠØ· Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù€ APIs Ø¨Ø¯ÙˆÙ† ØªØ¹Ù‚ÙŠØ¯.  
ÙŠØªØ¶Ù…Ù† Ø£Ù…Ø«Ù„Ø© Ù…Ø¨Ø§Ø´Ø±Ø© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª.

**ÙŠØºØ·ÙŠ:**
- Authentication (Register/Login)
- Profile Management
- Friends System
- User Relations
- Presence System
- WebSocket

---

## ğŸ“– API Documentation

### [API Documentation](./API_DOCUMENTATION.md) ğŸ“‹
**Ø§Ù„ØªÙˆØ«ÙŠÙ‚ Ø§Ù„ÙƒØ§Ù…Ù„ Ù„Ø¬Ù…ÙŠØ¹ REST APIs**

**ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰:**
- Ø¬Ù…ÙŠØ¹ Endpoints Ø¨Ø§Ù„ØªÙØµÙŠÙ„
- Request/Response Examples
- Validation Rules
- Error Handling
- Frontend Integration Examples

**Ø§Ù„Ù…Ø­ØªÙˆÙŠØ§Øª:**
1. Authentication APIs
2. User Profile APIs
3. Friendship APIs
4. User Relations APIs
5. Error Handling
6. Frontend Integration Guide

---

## ğŸ”´ Presence System

### [Redis Presence System](./REDIS_PRESENCE_SYSTEM.md) â­
**Ø¯Ù„ÙŠÙ„ Ø´Ø§Ù…Ù„ Ù„Ù†Ø¸Ø§Ù… Presence**

**Ù„Ù…Ø§Ø°Ø§ Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù Ù…Ù‡Ù…ØŸ**
- ÙŠØ´Ø±Ø­ ÙƒÙŠÙ ÙŠØ¹Ù…Ù„ Ù†Ø¸Ø§Ù… Presence Ù…Ø«Ù„ Discord
- ÙŠÙˆØ¶Ø­ Ø§Ù„ÙØ±Ù‚ Ø¨ÙŠÙ† Redis Ùˆ Database
- Ø£Ù…Ø«Ù„Ø© Ø¹Ù…Ù„ÙŠØ© Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…

**ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰:**
- Architecture Overview
- Redis Keys Structure
- Connection/Disconnection Flow
- ÙƒÙŠÙÙŠØ© Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Presence Status
- WebSocket Events
- REST API Endpoints
- Troubleshooting

### [Status System](./STATUS_SYSTEM.md) ğŸ”„
**Display Status vs Connection Status**

**ÙŠØ´Ø±Ø­:**
- Ø§Ù„ÙØ±Ù‚ Ø¨ÙŠÙ† Display Status Ùˆ Connection Status
- ÙƒÙŠÙ ÙŠØ¹Ù…Ù„ "Invisible Mode"
- Status Logic
- Client-Side Examples

---

## ğŸ”Œ WebSocket

### [Socket.IO Guide](./SOCKET_IO_GUIDE.md) ğŸ”Œ
**Ø¯Ù„ÙŠÙ„ WebSocket Events**

**ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰:**
- Client Integration
- WebSocket Events (Client â†” Server)
- Authentication
- Presence Management
- Testing Examples
- Configuration

### [WebSocket Testing](./WEBSOCKET_POSTMAN_TESTING.md) ğŸ§ª
**ÙƒÙŠÙÙŠØ© Testing WebSocket**

**ÙŠØ´Ø±Ø­:**
- ÙƒÙŠÙÙŠØ© Ø§Ø³ØªØ®Ø¯Ø§Ù… Postman Ù„Ù„Ù€ WebSocket
- Testing Scenarios
- Manual Testing
- Troubleshooting

---

## ğŸ—ï¸ Architecture

### [Backend Architecture](./BACKEND_ARCHITECTURE.md) ğŸ—ï¸
**Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø©**

**ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰:**
- System Architecture
- Project Structure
- Presence System Architecture
- Authentication Flow
- Data Flow Examples
- Database Schema
- Services & Repositories
- Key Design Decisions
- Performance Considerations

---

## ğŸ“Š Quick Reference

### API Endpoints Summary

#### Authentication
- `POST /api/v1/auth/register` - Register
- `POST /api/v1/auth/login` - Login

#### Profile
- `GET /api/v1/users/@me` - Get Profile
- `PUT /api/v1/users/@me/update/password` - Update Password
- `PUT /api/v1/users/@me/update/globalname` - Update Global Name
- `PUT /api/v1/users/@me/update/username` - Update Username
- `PUT /api/v1/users/@me/update/customstatus` - Update Custom Status
- `PUT /api/v1/users/@me/update/presenceStatus` - Update Status

#### Friends
- `POST /api/v1/users/friends/request` - Send Request
- `PUT /api/v1/users/friends/respond` - Respond to Request
- `GET /api/v1/users/friends` - Get Friends List
- `GET /api/v1/users/friends/requests/incoming` - Incoming Requests
- `GET /api/v1/users/friends/requests/outgoing` - Outgoing Requests
- `GET /api/v1/users/friends/mutual/{userId}` - Mutual Friends
- `GET /api/v1/users/friends/check/{userId}` - Check Friendship
- `DELETE /api/v1/users/friends/remove` - Remove Friend
- `DELETE /api/v1/users/friends/cancel` - Cancel Request

#### Relations
- `POST /api/v1/users/relations` - Create Relation (Block/Ignore/Mute)
- `GET /api/v1/users/relations` - Get All Relations
- `GET /api/v1/users/relations/blocked` - Get Blocked
- `GET /api/v1/users/relations/ignored` - Get Ignored
- `GET /api/v1/users/relations/muted` - Get Muted
- `GET /api/v1/users/relations/check` - Check Relation
- `PUT /api/v1/users/relations/note` - Update Note
- `DELETE /api/v1/users/relations` - Remove Relation
- `GET /api/v1/users/relations/stats` - Get Stats

### WebSocket Events

#### Client â†’ Server
- `status:get` - Get current status
- `status:update` - Update status (deprecated, use REST)

#### Server â†’ Client
- `connected` - Connection confirmed
- `status:current` - Current status response
- `presence:updated` - Friend status changed
- `status:updated` - Your status updated
- `friend:request:received` - New friend request
- `friend:request:accepted` - Friend request accepted
- `friend:request:rejected` - Friend request rejected
- `friend:request:cancelled` - Friend request cancelled

---

## ğŸ¯ Ø­Ø³Ø¨ Ø§Ù„Ù‡Ø¯Ù

### Ø£Ø±ÙŠØ¯ Ø£Ù† Ø£Ø¨Ø¯Ø£ Ø¨Ø³Ø±Ø¹Ø©
ğŸ‘‰ [Quick Start Guide](./QUICK_START_GUIDE.md)

### Ø£Ø±ÙŠØ¯ ØªÙØ§ØµÙŠÙ„ APIs ÙƒØ§Ù…Ù„Ø©
ğŸ‘‰ [API Documentation](./API_DOCUMENTATION.md)

### Ø£Ø±ÙŠØ¯ ÙÙ‡Ù… Ù†Ø¸Ø§Ù… Presence
ğŸ‘‰ [Redis Presence System](./REDIS_PRESENCE_SYSTEM.md)

### Ø£Ø±ÙŠØ¯ ÙÙ‡Ù… Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ©
ğŸ‘‰ [Backend Architecture](./BACKEND_ARCHITECTURE.md)

### Ø£Ø±ÙŠØ¯ Ø§Ø³ØªØ®Ø¯Ø§Ù… WebSocket
ğŸ‘‰ [Socket.IO Guide](./SOCKET_IO_GUIDE.md)

### Ø£Ø±ÙŠØ¯ Testing WebSocket
ğŸ‘‰ [WebSocket Testing](./WEBSOCKET_POSTMAN_TESTING.md)

---

## ğŸ’¡ Ù†ØµØ§Ø¦Ø­ Ù…Ù‡Ù…Ø©

### âœ… Ø§ÙØ¹Ù„

- âœ… Ø§Ø³ØªØ®Ø¯Ù… Redis Ù„Ù„Ù€ presence (Ù„ÙŠØ³ Database)
- âœ… Ø§Ø³ØªØ®Ø¯Ù… `getPresenceStatus()` Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø§Ù„Ø©
- âœ… Ø§Ø³ØªØ®Ø¯Ù… REST API Ù„ØªØ­Ø¯ÙŠØ« Status
- âœ… Ø§Ø³ØªÙ…Ø¹ Ù„Ù€ WebSocket events Ù„Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„ÙÙˆØ±ÙŠØ©

### âŒ Ù„Ø§ ØªÙØ¹Ù„

- âŒ Ù„Ø§ ØªØ³ØªØ®Ø¯Ù… `user.isOnline` Ù…Ù† Database
- âŒ Ù„Ø§ ØªÙØ­Ø¯Ø« `isOnline` ÙÙŠ Database
- âŒ Ù„Ø§ ØªØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Database Ù„Ù„Ù€ presence

---

## ğŸ”— Related Links

- [Main README](../README.md) - Project Overview
- [GitHub Repository](#) - Source Code

---

## ğŸ“ Support

Ø¥Ø°Ø§ Ø§Ø­ØªØ¬Øª Ù…Ø³Ø§Ø¹Ø¯Ø©:
1. Ø±Ø§Ø¬Ø¹ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø£Ø¹Ù„Ø§Ù‡
2. Ø±Ø§Ø¬Ø¹ Troubleshooting sections
3. ØªØ£ÙƒØ¯ Ù…Ù† Redis connection

---

**Last Updated:** 2024-01-15  
**Total Documentation Files:** 7



============================================================
FILE: docs/REDIS_PRESENCE_SYSTEM.md
============================================================
# Redis Presence System Documentation

## ğŸ“‹ Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø© (Overview)

Ù†Ø¸Ø§Ù… **Redis Presence System** Ù‡Ùˆ Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø­Ø§Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„ (Online/Offline) Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø¨Ø·Ø±ÙŠÙ‚Ø© Ù…Ø´Ø§Ø¨Ù‡Ø© Ù„Ù€ Discord.

### âœ… Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª

- **Real-time Presence**: Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ù† Redis (ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„ÙØ¹Ù„ÙŠ)
- **Volatile Storage**: Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ø§ ØªÙØ®Ø²Ù† ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (volatile)
- **Auto Cleanup**: Ø¹Ù†Ø¯ restart Ø§Ù„Ø³ÙŠØ±ÙØ±ØŒ ÙƒÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙŠØµØ¨Ø­ÙˆÙ† offline ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
- **Multi-Instance Support**: ÙŠØ¹Ù…Ù„ Ù…Ø¹ Ø¹Ø¯Ø© Ø³ÙŠØ±ÙØ±Ø§Øª Ø¹Ø¨Ø± Redis
- **Scalable**: Ø£Ø¯Ø§Ø¡ Ø¹Ø§Ù„ÙŠ Ù…Ø¹ Ø¹Ø¯Ø¯ ÙƒØ¨ÙŠØ± Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†

---

## ğŸ—ï¸ Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ© (Architecture)

### ÙƒÙŠÙ ÙŠØ¹Ù…Ù„ Ø§Ù„Ù†Ø¸Ø§Ù…ØŸ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Client    â”‚
â”‚  (Browser)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ WebSocket Connect
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Socket Gateway â”‚
â”‚  (NestJS)       â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â”€â–º Redis: presence:online:{userId} = 'true'
       â”œâ”€â”€â–º Redis: presence:sockets:{userId} = Set[socketId]
       â””â”€â”€â–º Redis: display:status:{userId} = 'ONLINE' | 'IDLE' | 'DND'
```

### Redis Keys Structure

```redis
# Connection Tracking
presence:{userId}:{socketId}          â†’ Hash {device, connectedAt, ip, lastPing}
presence:sockets:{userId}              â†’ Set of socketIds
presence:online:{userId}               â†’ 'true' | (deleted if offline)

# Display Status (User Choice)
display:status:{userId}                â†’ 'ONLINE' | 'IDLE' | 'DND' | 'Invisible'

# All keys have TTL:
# - Connection keys: 90 seconds
# - Display status: 24 hours
```

---

## ğŸ”„ ØªØ¯ÙÙ‚ Ø§Ù„Ø¹Ù…Ù„ (Flow)

### 1. Ø¹Ù†Ø¯ Ø§Ù„Ø§ØªØµØ§Ù„ (On Connect)

```typescript
// User connects via WebSocket
1. Client sends JWT token
2. Server validates token
3. Server calls: markOnline(userId, socketId, metadata)
   â”œâ”€â–º Stores socket metadata in Redis
   â”œâ”€â–º Adds socketId to Set
   â”œâ”€â–º Sets presence:online:{userId} = 'true'
   â””â”€â–º Sets TTL = 90 seconds

// Note: NO database update for isOnline!
```

### 2. Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù†ÙØµØ§Ù„ (On Disconnect)

```typescript
// User disconnects
1. Server calls: markOffline(userId, socketId)
   â”œâ”€â–º Removes socket from Set
   â”œâ”€â–º Checks if Set is empty
   â””â”€â–º If empty: Deletes presence:online:{userId}

// Note: NO database update!
```

### 3. Ø¹Ù†Ø¯ Restart Ø§Ù„Ø³ÙŠØ±ÙØ±

```typescript
// Server restarts
1. All Redis keys expire (TTL = 90s)
2. All users appear OFFLINE
3. When users reconnect â†’ They become ONLINE again

// This is INTENTIONAL - ensures accuracy!
```

---

## ğŸ“Š Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Presence Status

### Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© (Correct Way)

```typescript
// âœ… Use UnifiedPresenceService.getPresenceStatus()
const presence = await presenceService.getPresenceStatus(userId);

// Returns:
{
  isOnline: boolean,        // Real connection status from Redis
  displayStatus: UserStatus, // User's chosen status (IDLE, DND, etc.)
  actualStatus: UserStatus  // Final status to display
}
```

### âŒ Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø®Ø§Ø·Ø¦Ø© (Wrong Way)

```typescript
// âŒ DON'T use database isOnline field
const user = await userRepository.findById(userId);
if (user.isOnline) { ... } // WRONG! This is stale data
```

---

## ğŸ”Œ WebSocket Events

### Client â†’ Server

#### `status:get`
Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©

```javascript
socket.emit('status:get');
```

**Response:**
```javascript
socket.on('status:current', (data) => {
  console.log(data);
  // {
  //   connectionStatus: 'ONLINE' | 'Invisible',
  //   displayStatus: 'ONLINE' | 'IDLE' | 'DND' | 'Invisible',
  //   actualStatus: 'ONLINE' | 'IDLE' | 'DND' | 'Invisible'
  // }
});
```

#### `status:update` (Deprecated - Use REST API)
```javascript
// âš ï¸ Deprecated: Use PUT /users/@me/update/presenceStatus instead
socket.emit('status:update', { status: 'IDLE' });
```

### Server â†’ Client

#### `connected`
Ø¹Ù†Ø¯ Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ù†Ø§Ø¬Ø­

```javascript
socket.on('connected', (data) => {
  console.log(data);
  // {
  //   message: 'Connected successfully',
  //   userId: '123456789012345678',
  //   socketId: 'abc123...'
  // }
});
```

#### `status:current`
Ø±Ø¯ Ø¹Ù„Ù‰ `status:get`

```javascript
socket.on('status:current', (data) => {
  // See above
});
```

#### `presence:updated`
Ø¹Ù†Ø¯ ØªØ­Ø¯ÙŠØ« presence Ù„Ø£Ø­Ø¯ Ø§Ù„Ø£ØµØ¯Ù‚Ø§Ø¡

```javascript
socket.on('presence:updated', (data) => {
  console.log(data);
  // {
  //   userId: '123456789012345678',
  //   username: 'john_doe',
  //   status: 'IDLE',
  //   timestamp: '2024-01-15T10:30:00.000Z'
  // }
});
```

---

## ğŸŒ REST API Endpoints

### Profile Endpoints

#### `GET /api/v1/users/@me`
Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Profile (ÙŠØ´Ù…Ù„ `isOnline` Ù…Ù† Redis)

```http
GET /api/v1/users/@me
Authorization: Bearer <token>
```

**Response:**
```json
{
  "status": "success",
  "code": 200,
  "data": {
    "id": "5280662395293696",
    "username": "alice_dev",
    "globalname": "Alice Johnson",
    "email": "alice@discordclone.com",
    "isOnline": true,        // âœ… From Redis (real-time)
    "status": "IDLE",        // âœ… From Redis (display status)
    "customStatus": "Working on Discord Clone"
  }
}
```

#### `PUT /api/v1/users/@me/update/presenceStatus`
ØªØ­Ø¯ÙŠØ« Display Status (ONLINE, IDLE, DND, Invisible)

```http
PUT /api/v1/users/@me/update/presenceStatus
Authorization: Bearer <token>
Content-Type: application/json

{
  "status": "IDLE"
}
```

**Valid Values:**
- `"ONLINE"` - Online and available
- `"IDLE"` - Online but idle
- `"DND"` - Do Not Disturb
- `"Invisible"` - Appear offline (still connected)

---

## ğŸ’¡ Ø£Ù…Ø«Ù„Ø© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… (Examples)

### Example 1: Check if User is Online

```typescript
// âœ… Correct way
const presence = await presenceService.getPresenceStatus(userId);
if (presence.isOnline) {
  console.log('User is connected');
}

// âŒ Wrong way
const user = await userRepository.findById(userId);
if (user.isOnline) { // Stale data!
  console.log('User might be offline!');
}
```

### Example 2: Get Friend's Status

```typescript
// When fetching friends list
const friends = await usersService.getFriends(user);

// Each friend includes real-time status:
friends.forEach(friend => {
  console.log(`${friend.username}: ${friend.status}`); // âœ… From Redis
});
```

### Example 3: Update Your Status

```typescript
// Via REST API (Recommended)
await fetch('/api/v1/users/@me/update/presenceStatus', {
  method: 'PUT',
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ status: 'DND' })
});
```

---

## âš™ï¸ Configuration

### Environment Variables

```env
# Redis Configuration
CACHE_HOST=localhost
CACHE_PORT=6379
CACHE_PASS=

# JWT Configuration
JWT_SECRET_ACCESS=your_secret_key
JWT_EXPIRES_IN=7d
```

### TTL Settings

```typescript
// In UnifiedPresenceService
PRESENCE_TTL = 90;              // 90 seconds for connection tracking
DISPLAY_STATUS_TTL = 86400;     // 24 hours for display status
```

---

## ğŸ” Troubleshooting

### Ø§Ù„Ù…Ø´ÙƒÙ„Ø©: Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠØ¸Ù‡Ø± online ÙˆÙ‡Ùˆ offline

**Ø§Ù„Ø³Ø¨Ø¨:** Data Ù‚Ø¯ÙŠÙ…Ø© Ù…Ù† Database

**Ø§Ù„Ø­Ù„:** Ø§Ø³ØªØ®Ø¯Ù… `getPresenceStatus()` Ù…Ù† Redis

```typescript
// âŒ Wrong
const user = await userRepository.findById(userId);
const isOnline = user.isOnline; // Might be stale!

// âœ… Correct
const presence = await presenceService.getPresenceStatus(userId);
const isOnline = presence.isOnline; // Real-time!
```

### Ø§Ù„Ù…Ø´ÙƒÙ„Ø©: Ø¨Ø¹Ø¯ RestartØŒ ÙƒÙ„ Ø§Ù„Ù†Ø§Ø³ offline

**Ø§Ù„Ø³Ø¨Ø¨:** Ù‡Ø°Ø§ Ø³Ù„ÙˆÙƒ Ù…Ù‚ØµÙˆØ¯! (By Design)

**Ø§Ù„Ø­Ù„:** Ù‡Ø°Ø§ ØµØ­ÙŠØ­ âœ…
- Ø¹Ù†Ø¯ restart â†’ Redis ÙŠØªÙ… Ù…Ø³Ø­Ù‡ (volatile)
- Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø³ÙŠØ¸Ù‡Ø±ÙˆÙ† offline Ø­ØªÙ‰ ÙŠØ¹ÙŠØ¯ÙˆØ§ Ø§Ù„Ø§ØªØµØ§Ù„
- Ù‡Ø°Ø§ ÙŠØ¶Ù…Ù† Ø§Ù„Ø¯Ù‚Ø© - Ù„Ø§ ÙŠÙˆØ¬Ø¯ stale data

### Ø§Ù„Ù…Ø´ÙƒÙ„Ø©: Status Ù„Ø§ ÙŠØªØ­Ø¯Ø«

**Ø§Ù„Ø­Ù„:**
1. ØªØ£ÙƒØ¯ Ø£Ù† Redis ÙŠØ¹Ù…Ù„: `redis-cli ping`
2. ØªØ£ÙƒØ¯ Ø£Ù† WebSocket Ù…ØªØµÙ„
3. Ø§Ø³ØªØ®Ø¯Ù… REST API Ù„ØªØ­Ø¯ÙŠØ« Status

---

## ğŸ“ Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ù…Ù‡Ù…Ø© (Important Notes)

### âœ… DO (Ø§ÙØ¹Ù„)

- âœ… Ø§Ø³ØªØ®Ø¯Ù… `getPresenceStatus()` Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø§Ù„Ø©
- âœ… Ø§Ø¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Redis Ù„Ù„Ù€ presence
- âœ… Ø§Ø³ØªØ®Ø¯Ù… REST API Ù„ØªØ­Ø¯ÙŠØ« Status
- âœ… Ø§Ø³ØªÙ…Ø¹ Ù„Ù€ WebSocket events Ù„Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„ÙÙˆØ±ÙŠØ©

### âŒ DON'T (Ù„Ø§ ØªÙØ¹Ù„)

- âŒ Ù„Ø§ ØªØ³ØªØ®Ø¯Ù… `user.isOnline` Ù…Ù† Database
- âŒ Ù„Ø§ ØªÙØ­Ø¯Ø« `isOnline` ÙÙŠ Database
- âŒ Ù„Ø§ ØªØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Database Ù„Ù„Ù€ presence

---

## ğŸ”— Related Documentation

- [API Documentation](./API_DOCUMENTATION.md) - REST APIs Ø§Ù„ÙƒØ§Ù…Ù„Ø©
- [Socket.IO Guide](./SOCKET_IO_GUIDE.md) - WebSocket Events
- [Status System](./STATUS_SYSTEM.md) - Display Status vs Connection Status

---

## ğŸ“ Support

Ø¥Ø°Ø§ ÙˆØ§Ø¬Ù‡Øª Ù…Ø´Ø§ÙƒÙ„:
1. Ø±Ø§Ø¬Ø¹ Ø§Ù„Ù€ Troubleshooting section
2. ØªØ£ÙƒØ¯ Ù…Ù† Redis connection
3. Ø±Ø§Ø¬Ø¹ Ø§Ù„Ù€ logs ÙÙŠ console

---

**Last Updated:** 2024-01-15  
**Version:** 1.0.0



============================================================
FILE: docs/SOCKET_IO_GUIDE.md
============================================================
# Socket.IO Integration Guide

## Overview

The Discord Clone backend now supports **real-time communication** via Socket.IO with **Redis-based presence management** for multi-instance deployment.

## Features

âœ… **JWT Authentication** - Secure socket connections  
âœ… **Redis Presence** - Track online/offline status across instances (volatile, like Discord)  
âœ… **Real-time Status** - All presence data from Redis, NOT database  
âœ… **Multi-Instance Support** - Works across multiple server instances  
âœ… **Ping/Pong** - Connection health monitoring  
âœ… **Room Management** - Join user-specific rooms  

---

## Architecture

### Connection Flow

```
1. Client connects â†’ Send JWT token
2. Server validates token â†’ Extract userId
3. Store presence in Redis ONLY (NO database update!)
4. Join room: user:{userId}
5. Send confirmation to client
```

**Important:** Presence is stored in Redis only - NOT in database. This ensures real-time accuracy.

### Redis Data Structure

```redis
presence:{userId}:{socketId} â†’ {device, connectedAt, ip}
presence:sockets:{userId}     â†’ Set of socketIds
presence:online:{userId}      â†’ 'true'/'false'
```

### Disconnection Flow

```
1. Client disconnects
2. Remove socket from Redis
3. Check socket count
4. If count = 0 â†’ Remove presence:online:{userId} from Redis
5. Publish update via Redis Pub/Sub (optional)
```

**Important:** No database update - presence is volatile (like Discord).

---

## Client Integration

### 1. Install Client Library

```bash
npm install socket.io-client
```

### 2. Create Socket Client

```typescript
import { io, Socket } from 'socket.io-client';

class DiscordSocketClient {
  private socket: Socket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;

  connect(token: string) {
    if (this.socket?.connected) {
      console.log('Already connected');
      return;
    }

    this.socket = io('http://localhost:3000', {
      auth: { token },
      reconnection: true,
      reconnectionAttempts: this.maxReconnectAttempts,
      reconnectionDelay: 1000,
    });

    this.setupEventListeners();
  }

  private setupEventListeners() {
    if (!this.socket) return;

    // Connection events
    this.socket.on('connect', () => {
      console.log('âœ… Connected to server');
      this.reconnectAttempts = 0;
    });

    this.socket.on('disconnect', (reason) => {
      console.log('âŒ Disconnected:', reason);
    });

    this.socket.on('connect_error', (error) => {
      console.error('Connection error:', error.message);
      this.reconnectAttempts++;

      if (this.reconnectAttempts >= this.maxReconnectAttempts) {
        console.error('Max reconnection attempts reached');
      }
    });

    // Server confirmation
    this.socket.on('connected', (data) => {
      console.log('Server confirmed connection:', data);
    });

    // Presence updates
    this.socket.on('presence:updated', (data) => {
      console.log('Presence update:', data);
      // Update UI with new status
    });
  }

  // Ping to keep connection alive
  startPing() {
    if (!this.socket) return;

    setInterval(() => {
      this.socket?.emit('ping');
    }, 30000); // Every 30 seconds
  }

  // Update user status
  updateStatus(status: 'ONLINE' | 'OFFLINE' | 'IDLE' | 'DND') {
    if (!this.socket) return;

    this.socket.emit('presence:update', { status });
  }

  // Disconnect
  disconnect() {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }
  }
}

export default DiscordSocketClient;
```

### 3. React Hook Example

```typescript
import { useEffect, useState, useCallback } from 'react';
import DiscordSocketClient from './DiscordSocketClient';

const useSocket = (token: string | null) => {
  const [socket, setSocket] = useState<DiscordSocketClient | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [presence, setPresence] = useState<any>(null);

  useEffect(() => {
    if (!token) return;

    const client = new DiscordSocketClient();
    client.connect(token);
    
    client.on('connected', () => {
      setIsConnected(true);
    });

    client.on('presence:updated', (data) => {
      setPresence(data);
    });

    setSocket(client);

    return () => {
      client.disconnect();
    };
  }, [token]);

  const updateStatus = useCallback((status: 'ONLINE' | 'OFFLINE' | 'IDLE' | 'DND') => {
    socket?.updateStatus(status);
  }, [socket]);

  return {
    socket,
    isConnected,
    presence,
    updateStatus,
  };
};

export default useSocket;
```

### 4. Usage in Component

```typescript
import React, { useEffect } from 'react';
import useSocket from './hooks/useSocket';

const ChatComponent: React.FC = () => {
  const token = localStorage.getItem('accessToken');
  const { isConnected, presence, updateStatus } = useSocket(token);

  useEffect(() => {
    // Update status when component mounts
    if (isConnected) {
      updateStatus('ONLINE');
    }
  }, [isConnected]);

  const handleIdle = () => {
    updateStatus('IDLE');
  };

  const handleBack = () => {
    updateStatus('ONLINE');
  };

  return (
    <div>
      {isConnected ? (
        <p>âœ… Connected</p>
      ) : (
        <p>âŒ Disconnected</p>
      )}

      {presence && (
        <p>Status: {presence.status}</p>
      )}

      <button onClick={handleIdle}>Set Idle</button>
      <button onClick={handleBack}>Back Online</button>
    </div>
  );
};

export default ChatComponent;
```

---

## API Endpoints

### Events

#### Client â†’ Server

**`ping`** - Keep connection alive
```typescript
socket.emit('ping');
// Server responds with 'pong'
```

**`presence:update`** - Update user status
```typescript
socket.emit('presence:update', {
  status: 'ONLINE' | 'OFFLINE' | 'IDLE' | 'DND'
});
```

#### Server â†’ Client

**`connected`** - Connection confirmed
```typescript
socket.on('connected', (data) => {
  console.log(data.userId);
  console.log(data.socketId);
});
```

**`pong`** - Ping response
```typescript
socket.on('pong', () => {
  console.log('Server alive');
});
```

**`presence:updated`** - Status update
```typescript
socket.on('presence:updated', (data) => {
  console.log(data.userId);
  console.log(data.status);
  console.log(data.timestamp);
});
```

---

## How It Works

### Authentication

```typescript
// Client sends JWT token in auth
const socket = io('http://localhost:3000', {
  auth: { token: 'your_jwt_token' }
});

// Server validates and extracts userId
// If invalid â†’ disconnect immediately
```

### Presence Management

#### Online Detection

```typescript
// When user connects
await presenceService.markOnline(userId, socketId, {
  device: 'web',
  connectedAt: new Date(),
  ip: clientIp,
});

// Redis stores:
// - Socket metadata
// - Socket IDs set
// - Online status flag
```

#### Offline Detection

```typescript
// When user disconnects
await presenceService.markOffline(userId, socketId);

// Redis removes socket and checks count
// If no sockets left â†’ delete presence:online:{userId}
// NO database update - presence is volatile!
```

### TTL & Auto-Cleanup

```typescript
// Every socket connection has 90s TTL
// Ping resets TTL
// Dead connections auto-removed

// Client should ping every 30s
setInterval(() => socket.emit('ping'), 30000);
```

### Multi-Instance Support

```typescript
// Redis Pub/Sub broadcasts presence updates
// All instances receive and react
// Keeps all servers in sync
```

---

## Testing

### 1. Start Redis

```bash
redis-server
```

### 2. Start Backend

```bash
npm run start:dev
```

### 3. Connect Client

```typescript
import io from 'socket.io-client';

const socket = io('http://localhost:3000', {
  auth: { token: 'your_jwt_token_here' }
});

socket.on('connect', () => {
  console.log('Connected!');
});

socket.on('connected', (data) => {
  console.log('User ID:', data.userId);
  console.log('Socket ID:', data.socketId);
});
```

### 4. Test Presence

```typescript
// Update status
socket.emit('presence:update', { status: 'IDLE' });

// Listen for updates
socket.on('presence:updated', (data) => {
  console.log('Status changed:', data.status);
});
```

---

## Configuration

### Environment Variables

```env
# Redis Configuration
CACHE_HOST=localhost
CACHE_PORT=6379
CACHE_PASS=

# JWT Configuration (already exists)
JWT_SECRET_ACCESS=your_secret_key
JWT_EXPIRES_IN=7d
```

### WebSocket CORS

Update in `websocket.gateway.ts`:

```typescript
@WebSocketGateway({
  cors: {
    origin: ['http://localhost:3000', 'https://yourdomain.com'],
    credentials: true,
  },
})
```

---

## Troubleshooting

### Connection Fails

**Problem:** Cannot connect to server

**Solutions:**
- Check Redis is running: `redis-cli ping`
- Verify JWT token is valid
- Check CORS configuration
- Verify port 3000 is open

### Status Not Updating

**Problem:** Database status doesn't change

**Solutions:**
- Check Redis connection
- Verify userId is correct
- Check database permissions
- Review logs for errors

### Multiple Instances Issues

**Problem:** Presence updates not syncing

**Solutions:**
- Verify Redis Pub/Sub is working
- Check Redis adapter is properly configured
- Ensure all instances connect to same Redis

---

## Summary

âœ… **Authentication:** JWT-based secure connections  
âœ… **Redis Storage:** Multi-instance presence tracking  
âœ… **Auto Status Update:** Automatic ONLINE/OFFLINE  
âœ… **TTL Management:** 90s TTL with ping refresh  
âœ… **Room System:** User-specific rooms  
âœ… **Pub/Sub:** Cross-instance synchronization  
âœ… **Ping/Pong:** Connection health monitoring  

The socket system is now ready for production use!



============================================================
FILE: docs/STATUS_SYSTEM.md
============================================================
# Status System Documentation

## Overview

The system uses a **dual-status** mechanism (stored in **Redis**, NOT database):
- **Connection Status**: Real connection state (Socket.IO â†’ Redis)
- **Display Status**: What the user wants to show (User-controlled â†’ Redis)

**Important:** All status data comes from **Redis** - it's volatile and real-time!

## How It Works

### Status Flow

```
User opens site â†’ Actual: ONLINE
     â†“
User chooses IDLE â†’ Display: IDLE
     â†“
User goes offline â†’ Actual: OFFLINE â†’ Display forced to OFFLINE
```

### Examples

#### Scenario 1: User wants to be invisible
```typescript
// User is online, but wants to appear offline
socket.emit('status:update', { status: 'OFFLINE' });

// Result:
// Actual: ONLINE (socket connected)
// Display: OFFLINE (user choice)
// Friends see: OFFLINE
```

#### Scenario 2: User wants to be idle
```typescript
// User active, but not doing anything
socket.emit('status:update', { status: 'IDLE' });

// Result:
// Actual: ONLINE
// Display: IDLE
// Friends see: IDLE
```

#### Scenario 3: User disconnects
```typescript
// User closes browser/tab
// Automatic disconnect

// Result:
// Actual: OFFLINE (forced)
// Display: OFFLINE (forced)
// Friends see: OFFLINE
```

## API Usage

### Update Display Status

```typescript
// Client code
socket.emit('status:update', { 
  status: 'IDLE' // or 'ONLINE', 'DND', 'OFFLINE'
});

// Listen for confirmation
socket.on('status:updated', (data) => {
  console.log('Status changed:', data.status);
});
```

### Get Current Status

```typescript
// Get both actual and display status
socket.emit('status:get');

// Listen for response
socket.on('status:current', (data) => {
  console.log('Display:', data.displayStatus); // What user wants
  console.log('Actual:', data.actualStatus);   // Real connection
});
```

## Data Storage

### Redis Structure

```redis
display:status:{userId} â†’ 'ONLINE' | 'IDLE' | 'DND' | 'OFFLINE'
```

### Storage (Redis)

Both connection and display status are stored in **Redis**:
- `presence:online:{userId}` â†’ Connection status (true/false)
- `display:status:{userId}` â†’ Display status (ONLINE, IDLE, DND, Invisible)

**Note:** The `status` field in the `Presence` table is optional and may be outdated. Always use Redis for real-time status!

## Status Logic

### Display Rules

1. **User Online + Chooses Status** â†’ Display = Chosen Status
2. **User Disconnects** â†’ Display = OFFLINE (forced)
3. **User Reconnects** â†’ Display = Last chosen status (or ONLINE)

### Implementation

```typescript
// When user updates status (via REST API)
PUT /api/v1/users/@me/update/presenceStatus
// â†’ Updates Redis: display:status:{userId}
// â†’ Optionally updates DB Presence table (for display only)

// When displaying status to friends
const presence = await presenceService.getPresenceStatus(userId);
// Returns: { isOnline, displayStatus, actualStatus }

// Show to friends
const finalStatus = presence.actualStatus; // Handles offline automatically
```

## Client-Side Example

```typescript
class StatusManager {
  private socket: Socket;

  constructor(socket: Socket) {
    this.socket = socket;
    this.setupListeners();
  }

  // Set status manually
  setStatus(status: 'ONLINE' | 'IDLE' | 'DND' | 'OFFLINE') {
    this.socket.emit('status:update', { status });
  }

  // Get current status
  getStatus() {
    this.socket.emit('status:get');
  }

  // Listen for status updates from server
  onStatusUpdate(callback: (data: any) => void) {
    this.socket.on('status:updated', callback);
  }

  // Listen for current status response
  onStatusCurrent(callback: (data: any) => void) {
    this.socket.on('status:current', callback);
  }

  private setupListeners() {
    this.onStatusUpdate((data) => {
      console.log('Status updated:', data.status);
      // Update UI
    });

    this.onStatusCurrent((data) => {
      console.log('Current status:', data.displayStatus);
      console.log('Actual status:', data.actualStatus);
      // Update UI
    });
  }
}
```

## Auto-Idle Detection (Future Enhancement)

For automatic IDLE detection, you can add:

```typescript
// After 5 minutes of no user activity
setTimeout(() => {
  if (userNotActive) {
    socket.emit('status:update', { status: 'IDLE' });
  }
}, 5 * 60 * 1000);
```

## Status Priority

| Actual Status | User Choice | Displayed Status |
|--------------|-------------|------------------|
| ONLINE | OFFLINE | OFFLINE (invisible) |
| ONLINE | IDLE | IDLE |
| ONLINE | DND | DND |
| ONLINE | ONLINE | ONLINE |
| OFFLINE | * | OFFLINE (forced) |

This provides the perfect "invisible mode" feature where users can be online but appear offline to others.



============================================================
FILE: docs/WEBSOCKET_POSTMAN_TESTING.md
============================================================
# WebSocket Testing with Postman

## Overview

This guide shows how to test WebSocket connections using Postman's WebSocket support.

## Prerequisites

1. Latest Postman version (with WebSocket support)
2. Server running on `localhost:3000`
3. Valid JWT access token

---

## Step 1: Get Access Token

Before connecting to WebSocket, get your access token:

```http
POST http://localhost:3000/api/v1/auth/register
Content-Type: application/json

{
  "username": "test_user",
  "email": "test@example.com",
  "password": "Test123!",
  "birthdate": "2000-01-01"
}
```

Or login:

```http
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json

{
  "email": "test@example.com",
  "password": "Test123!"
}
```

Save the `accessToken` from the response.

---

## Step 2: Connect to WebSocket

### Using Postman UI

1. Open Postman
2. Click **New** â†’ **WebSocket Request**
3. Enter URL: `ws://localhost:3000`
4. Add header:
   ```
   Authorization: Bearer <your_jwt_token>
   ```
5. Click **Connect**

### Expected Response

```json
{
  "message": "Connected successfully",
  "userId": "123456789012345678",
  "socketId": "abc123..."
}
```

---

## Step 3: Test Status Update

After connecting, send messages to test status updates:

### Set Status to IDLE

```json
{
  "event": "status:update",
  "data": {
    "status": "IDLE"
  }
}
```

### Set Status to DND

```json
{
  "event": "status:update",
  "data": {
    "status": "DND"
  }
}
```

### Set Status to OFFLINE (Invisible)

```json
{
  "event": "status:update",
  "data": {
    "status": "OFFLINE"
  }
}
```

### Expected Response

```json
{
  "event": "status:updated",
  "data": {
    "userId": "123456789012345678",
    "status": "IDLE",
    "timestamp": "2024-01-15T10:30:00.000Z"
  }
}
```

---

## Step 4: Get Current Status

### Request

```json
{
  "event": "status:get",
  "data": {}
}
```

### Expected Response

```json
{
  "event": "status:current",
  "data": {
    "displayStatus": "IDLE",
    "actualStatus": "ONLINE"
  }
}
```

---

## Step 5: Test Ping (Optional)

### Request

```json
{
  "event": "ping",
  "data": {}
}
```

### Expected Response

```json
{
  "event": "pong",
  "data": {}
}
```

---

## Complete Testing Flow

### 1. Register/Login

```javascript
// Use existing REST API
POST /auth/register
â†’ Get accessToken
```

### 2. Connect to WebSocket

```javascript
ws://localhost:3000
Header: Authorization: Bearer <token>
â†’ Should receive 'connected' event
```

### 3. Test Status Updates

```javascript
// Send
{ "event": "status:update", "data": { "status": "IDLE" } }
// Receive
{ "event": "status:updated", "data": {...} }
```

### 4. Test Get Status

```javascript
// Send
{ "event": "status:get", "data": {} }
// Receive
{ "event": "status:current", "data": {...} }
```

### 5. Disconnect

```javascript
// Close connection or send disconnect event
â†’ Check if status changed to OFFLINE in database
```

---

## Postman Collection Structure

```json
{
  "info": {
    "name": "Discord WebSocket API"
  },
  "item": [
    {
      "name": "Connect",
      "request": {
        "method": "GET",
        "url": {
          "raw": "ws://localhost:3000"
        },
        "header": [
          {
            "key": "Authorization",
            "value": "Bearer {{accessToken}}"
          }
        ]
      }
    }
  ]
}
```

---

## Testing Scenarios

### Scenario 1: Normal Status Change

```
1. Connect â†’ Receives 'connected'
2. Update status to IDLE â†’ Receives 'status:updated'
3. Get status â†’ Receives 'status:current' with IDLE
4. Update status to DND â†’ Receives 'status:updated'
5. Disconnect â†’ Status should be OFFLINE
```

### Scenario 2: Invisible Mode

```
1. Connect â†’ Actual: ONLINE
2. Set status to OFFLINE â†’ Display: OFFLINE, Actual: ONLINE
3. Check database â†’ Should show OFFLINE
4. Disconnect â†’ Both should be OFFLINE
```

### Scenario 3: Multi-Device

```
1. Connect Device 1 â†’ Online
2. Update status on Device 1 â†’ IDLE
3. Connect Device 2 â†’ Should receive status as IDLE
4. Update status on Device 2 â†’ DND
5. Device 1 should receive status update event
```

---

## Troubleshooting

### Connection Failed

**Problem:** Cannot connect to WebSocket

**Solutions:**
- Check if server is running
- Verify JWT token is valid
- Check CORS configuration
- Try with different connection protocol (ws/wss)

### No Response

**Problem:** Connected but no responses

**Solutions:**
- Check server logs for errors
- Verify Redis is running
- Check network tab in browser developer tools
- Verify event names are correct

### Status Not Updating

**Problem:** Status change not reflected

**Solutions:**
- Check Redis connection
- Verify database update
- Check for errors in server logs
- Verify userId is correct

---

## Manual cURL Alternative

If Postman doesn't work, use a WebSocket client:

```bash
npm install -g wscat
wscat -c ws://localhost:3000 -H "Authorization: Bearer YOUR_TOKEN"
```

Then send events manually:

```json
{"event": "status:update", "data": {"status": "IDLE"}}
```

---

## Reference

### Available Events

#### Client â†’ Server

- `status:update` - Update display status
- `status:get` - Get current status
- `ping` - Ping server (optional)

#### Server â†’ Client

- `connected` - Connection established
- `status:updated` - Status change confirmed
- `status:current` - Current status response
- `pong` - Ping response (optional)

---

## Next Steps

1. Test all status transitions
2. Test with multiple devices
3. Test disconnect scenarios
4. Test with invalid tokens
5. Test with Redis down scenario



============================================================
FILE: postman/User1_Alice.postman_collection.json
============================================================
{
	"info": {
		"_postman_id": "user1-alice-001",
		"name": "User 1 - Alice (Main User)",
		"description": "Discord Clone API - User 1 (Alice) - Main testing user with full permissions",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "Health Check",
			"item": [
				{
					"name": "Health Check",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/health",
							"host": ["{{baseUrl}}"],
							"path": ["health"]
						}
					}
				}
			]
		},
		{
			"name": "Authentication",
			"item": [
				{
					"name": "Register Alice",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response && pm.response.json()) {",
									"    const response = pm.response.json();",
									"    if (response.data && response.data.accessToken) {",
									"        pm.collectionVariables.set('accessToken', response.data.accessToken);",
									"        console.log('âœ… Alice access token saved');",
									"    }",
									"    if (response.data && response.data.user && response.data.user.id) {",
									"        pm.collectionVariables.set('userId', response.data.user.id);",
									"        console.log('âœ… Alice user ID saved:', response.data.user.id);",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [{"key": "Content-Type", "value": "application/json"}],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"username\": \"alice_dev\",\n  \"email\": \"alice@discordclone.com\",\n  \"password\": \"alice123456\",\n  \"phone\": \"+1234567890\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/auth/register",
							"host": ["{{baseUrl}}"],
							"path": ["auth", "register"]
						}
					}
				},
				{
					"name": "Login Alice",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response && pm.response.json()) {",
									"    const response = pm.response.json();",
									"    if (response.data && response.data.accessToken) {",
									"        pm.collectionVariables.set('accessToken', response.data.accessToken);",
									"        console.log('âœ… Alice logged in successfully');",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [{"key": "Content-Type", "value": "application/json"}],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"email\": \"alice@discordclone.com\",\n  \"password\": \"alice123456\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/auth/login",
							"host": ["{{baseUrl}}"],
							"path": ["auth", "login"]
						}
					}
				}
			]
		},
		{
			"name": "Profile Management",
			"item": [
				{
					"name": "Get Alice Profile",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/profile",
							"host": ["{{baseUrl}}"],
							"path": ["users", "profile"]
						}
					}
				},
				{
					"name": "Update Alice Global Name",
					"request": {
						"method": "PUT",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"globalname\": \"Alice Johnson\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/profile/global-name",
							"host": ["{{baseUrl}}"],
							"path": ["users", "profile", "global-name"]
						}
					}
				},
				{
					"name": "Update Alice Custom Status",
					"request": {
						"method": "PUT",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"customStatus\": \"Working on Discord Clone\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/profile/custom-status",
							"host": ["{{baseUrl}}"],
							"path": ["users", "profile", "custom-status"]
						}
					}
				},
				{
					"name": "Update Alice Username",
					"request": {
						"method": "PUT",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"username\": \"alice_updated\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/profile/username",
							"host": ["{{baseUrl}}"],
							"path": ["users", "profile", "username"]
						}
					}
				},
				{
					"name": "Update Alice Password",
					"request": {
						"method": "PUT",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"currentPassword\": \"alice123456\",\n  \"newPassword\": \"alice_new_password\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/profile/password",
							"host": ["{{baseUrl}}"],
							"path": ["users", "profile", "password"]
						}
					}
				}
			]
		},
		{
			"name": "Friends Management",
			"item": [
				{
					"name": "Send Friend Request to Bob",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response && pm.response.json()) {",
									"    const response = pm.response.json();",
									"    if (response.data && response.data.id) {",
									"        pm.collectionVariables.set('friendshipId', response.data.id);",
									"        console.log('âœ… Friend request to Bob sent');",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"username\": \"bob_dev\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/friends/request",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "request"]
						}
					}
				},
				{
					"name": "Send Friend Request to Charlie",
					"request": {
						"method": "POST",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"username\": \"charlie_dev\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/friends/request",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "request"]
						}
					}
				},
				{
					"name": "Get Alice Friends List",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/friends",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends"]
						}
					}
				},
				{
					"name": "Get Alice Incoming Requests",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/friends/requests/incoming",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "requests", "incoming"]
						}
					}
				},
				{
					"name": "Get Alice Outgoing Requests",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/friends/requests/outgoing",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "requests", "outgoing"]
						}
					}
				},
				{
					"name": "Get Mutual Friends with Bob",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/friends/mutual/{{bobUserId}}",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "mutual", "{{bobUserId}}"]
						}
					}
				},
				{
					"name": "Check Friendship with Bob",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/friends/check/{{bobUserId}}",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "check", "{{bobUserId}}"]
						}
					}
				},
				{
					"name": "Remove Friend Bob",
					"request": {
						"method": "DELETE",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"userId\": \"{{bobUserId}}\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/friends/remove",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "remove"]
						}
					}
				}
			]
		},
		{
			"name": "User Relations",
			"item": [
				{
					"name": "Block Bob",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response && pm.response.json()) {",
									"    const response = pm.response.json();",
									"    if (response.data && response.data.id) {",
									"        pm.collectionVariables.set('relationId', response.data.id);",
									"        console.log('âœ… Bob blocked successfully');",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"targetUserId\": \"{{bobUserId}}\",\n  \"type\": \"BLOCKED\",\n  \"note\": \"Spam user\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/relations",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations"]
						}
					}
				},
				{
					"name": "Ignore Charlie",
					"request": {
						"method": "POST",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"targetUserId\": \"{{charlieUserId}}\",\n  \"type\": \"IGNORED\",\n  \"note\": \"Annoying messages\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/relations",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations"]
						}
					}
				},
				{
					"name": "Mute Bob",
					"request": {
						"method": "POST",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"targetUserId\": \"{{bobUserId}}\",\n  \"type\": \"MUTED\",\n  \"note\": \"Too many notifications\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/relations",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations"]
						}
					}
				},
				{
					"name": "Get All Relations",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/relations",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations"]
						}
					}
				},
				{
					"name": "Get Blocked Users",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/relations/blocked",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations", "blocked"]
						}
					}
				},
				{
					"name": "Get Ignored Users",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/relations/ignored",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations", "ignored"]
						}
					}
				},
				{
					"name": "Get Muted Users",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/relations/muted",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations", "muted"]
						}
					}
				},
				{
					"name": "Check Relation with Bob",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/relations/check?targetUserId={{bobUserId}}&type=BLOCKED",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations", "check"],
							"query": [
								{"key": "targetUserId", "value": "{{bobUserId}}"},
								{"key": "type", "value": "BLOCKED"}
							]
						}
					}
				},
				{
					"name": "Update Relation Note",
					"request": {
						"method": "PUT",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"targetUserId\": \"{{bobUserId}}\",\n  \"type\": \"BLOCKED\",\n  \"note\": \"Updated reason for blocking\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/relations/note",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations", "note"]
						}
					}
				},
				{
					"name": "Remove Block from Bob",
					"request": {
						"method": "DELETE",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"targetUserId\": \"{{bobUserId}}\",\n  \"type\": \"BLOCKED\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/relations",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations"]
						}
					}
				},
				{
					"name": "Get Relation Stats",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/relations/stats",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations", "stats"]
						}
					}
				}
			]
		}
	],
	"variable": [
		{"key": "baseUrl", "value": "http://localhost:3000/api/v1", "type": "string"},
		{"key": "accessToken", "value": "", "type": "string"},
		{"key": "userId", "value": "", "type": "string"},
		{"key": "friendshipId", "value": "", "type": "string"},
		{"key": "bobUserId", "value": "", "type": "string"},
		{"key": "charlieUserId", "value": "", "type": "string"},
		{"key": "relationId", "value": "", "type": "string"}
	]
}


============================================================
FILE: postman/User2_Bob.postman_collection.json
============================================================
{
	"info": {
		"_postman_id": "user2-bob-002",
		"name": "User 2 - Bob (Friend User)",
		"description": "Discord Clone API - User 2 (Bob) - Friend testing user for Alice",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "Authentication",
			"item": [
				{
					"name": "Register Bob",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response && pm.response.json()) {",
									"    const response = pm.response.json();",
									"    if (response.data && response.data.accessToken) {",
									"        pm.collectionVariables.set('accessToken', response.data.accessToken);",
									"        console.log('âœ… Bob access token saved');",
									"    }",
									"    if (response.data && response.data.user && response.data.user.id) {",
									"        pm.collectionVariables.set('userId', response.data.user.id);",
									"        console.log('âœ… Bob user ID saved:', response.data.user.id);",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [{"key": "Content-Type", "value": "application/json"}],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"username\": \"bob_dev\",\n  \"email\": \"bob@discordclone.com\",\n  \"password\": \"bob123456\",\n  \"phone\": \"+1234567891\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/auth/register",
							"host": ["{{baseUrl}}"],
							"path": ["auth", "register"]
						}
					}
				},
				{
					"name": "Login Bob",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response && pm.response.json()) {",
									"    const response = pm.response.json();",
									"    if (response.data && response.data.accessToken) {",
									"        pm.collectionVariables.set('accessToken', response.data.accessToken);",
									"        console.log('âœ… Bob logged in successfully');",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [{"key": "Content-Type", "value": "application/json"}],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"email\": \"bob@discordclone.com\",\n  \"password\": \"bob123456\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/auth/login",
							"host": ["{{baseUrl}}"],
							"path": ["auth", "login"]
						}
					}
				}
			]
		},
		{
			"name": "Profile Management",
			"item": [
				{
					"name": "Get Bob Profile",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/profile",
							"host": ["{{baseUrl}}"],
							"path": ["users", "profile"]
						}
					}
				},
				{
					"name": "Update Bob Global Name",
					"request": {
						"method": "PUT",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"globalname\": \"Bob Smith\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/profile/global-name",
							"host": ["{{baseUrl}}"],
							"path": ["users", "profile", "global-name"]
						}
					}
				},
				{
					"name": "Update Bob Custom Status",
					"request": {
						"method": "PUT",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"customStatus\": \"Testing Discord Clone API\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/profile/custom-status",
							"host": ["{{baseUrl}}"],
							"path": ["users", "profile", "custom-status"]
						}
					}
				},
				{
					"name": "Update Bob Username",
					"request": {
						"method": "PUT",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"username\": \"bob_updated\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/profile/username",
							"host": ["{{baseUrl}}"],
							"path": ["users", "profile", "username"]
						}
					}
				},
				{
					"name": "Update Bob Password",
					"request": {
						"method": "PUT",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"currentPassword\": \"bob123456\",\n  \"newPassword\": \"bob_new_password\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/profile/password",
							"host": ["{{baseUrl}}"],
							"path": ["users", "profile", "password"]
						}
					}
				}
			]
		},
		{
			"name": "Friends Management",
			"item": [
				{
					"name": "Get Bob Incoming Requests",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response && pm.response.json()) {",
									"    const response = pm.response.json();",
									"    if (Array.isArray(response.data) && response.data.length > 0) {",
									"        pm.collectionVariables.set('friendshipId', response.data[0].id);",
									"        console.log('âœ… Bob friendship ID saved:', response.data[0].id);",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/friends/requests/incoming",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "requests", "incoming"]
						}
					}
				},
				{
					"name": "Accept Alice Friend Request",
					"request": {
						"method": "PUT",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"friendshipId\": \"{{friendshipId}}\",\n  \"status\": \"ACCEPTED\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/friends/respond",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "respond"]
						}
					}
				},
				{
					"name": "Send Friend Request to Charlie",
					"request": {
						"method": "POST",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"username\": \"charlie_dev\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/friends/request",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "request"]
						}
					}
				},
				{
					"name": "Get Bob Friends List",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/friends",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends"]
						}
					}
				},
				{
					"name": "Get Bob Outgoing Requests",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/friends/requests/outgoing",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "requests", "outgoing"]
						}
					}
				},
				{
					"name": "Get Mutual Friends with Alice",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/friends/mutual/{{aliceUserId}}",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "mutual", "{{aliceUserId}}"]
						}
					}
				},
				{
					"name": "Check Friendship with Alice",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/friends/check/{{aliceUserId}}",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "check", "{{aliceUserId}}"]
						}
					}
				},
				{
					"name": "Remove Friend Alice",
					"request": {
						"method": "DELETE",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"userId\": \"{{aliceUserId}}\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/friends/remove",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "remove"]
						}
					}
				}
			]
		},
		{
			"name": "User Relations",
			"item": [
				{
					"name": "Block Alice",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response && pm.response.json()) {",
									"    const response = pm.response.json();",
									"    if (response.data && response.data.id) {",
									"        pm.collectionVariables.set('relationId', response.data.id);",
									"        console.log('âœ… Alice blocked successfully');",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"targetUserId\": \"{{aliceUserId}}\",\n  \"type\": \"BLOCKED\",\n  \"note\": \"Unwanted contact\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/relations",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations"]
						}
					}
				},
				{
					"name": "Ignore Charlie",
					"request": {
						"method": "POST",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"targetUserId\": \"{{charlieUserId}}\",\n  \"type\": \"IGNORED\",\n  \"note\": \"Too many messages\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/relations",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations"]
						}
					}
				},
				{
					"name": "Mute Alice",
					"request": {
						"method": "POST",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"targetUserId\": \"{{aliceUserId}}\",\n  \"type\": \"MUTED\",\n  \"note\": \"Too many notifications\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/relations",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations"]
						}
					}
				},
				{
					"name": "Get All Relations",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/relations",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations"]
						}
					}
				},
				{
					"name": "Get Blocked Users",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/relations/blocked",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations", "blocked"]
						}
					}
				},
				{
					"name": "Get Ignored Users",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/relations/ignored",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations", "ignored"]
						}
					}
				},
				{
					"name": "Get Muted Users",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/relations/muted",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations", "muted"]
						}
					}
				},
				{
					"name": "Check Relation with Alice",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/relations/check?targetUserId={{aliceUserId}}&type=BLOCKED",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations", "check"],
							"query": [
								{"key": "targetUserId", "value": "{{aliceUserId}}"},
								{"key": "type", "value": "BLOCKED"}
							]
						}
					}
				},
				{
					"name": "Update Relation Note",
					"request": {
						"method": "PUT",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"targetUserId\": \"{{aliceUserId}}\",\n  \"type\": \"BLOCKED\",\n  \"note\": \"Updated reason for blocking\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/relations/note",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations", "note"]
						}
					}
				},
				{
					"name": "Remove Block from Alice",
					"request": {
						"method": "DELETE",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"targetUserId\": \"{{aliceUserId}}\",\n  \"type\": \"BLOCKED\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/relations",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations"]
						}
					}
				},
				{
					"name": "Get Relation Stats",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/relations/stats",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations", "stats"]
						}
					}
				}
			]
		}
	],
	"variable": [
		{"key": "baseUrl", "value": "http://localhost:3000/api/v1", "type": "string"},
		{"key": "accessToken", "value": "", "type": "string"},
		{"key": "userId", "value": "", "type": "string"},
		{"key": "friendshipId", "value": "", "type": "string"},
		{"key": "aliceUserId", "value": "", "type": "string"},
		{"key": "charlieUserId", "value": "", "type": "string"},
		{"key": "relationId", "value": "", "type": "string"}
	]
}


============================================================
FILE: postman/User3_Charlie.postman_collection.json
============================================================
{
	"info": {
		"_postman_id": "user3-charlie-003",
		"name": "User 3 - Charlie (Third User)",
		"description": "Discord Clone API - User 3 (Charlie) - Third testing user for mutual friends testing",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "Authentication",
			"item": [
				{
					"name": "Register Charlie",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response && pm.response.json()) {",
									"    const response = pm.response.json();",
									"    if (response.data && response.data.accessToken) {",
									"        pm.collectionVariables.set('accessToken', response.data.accessToken);",
									"        console.log('âœ… Charlie access token saved');",
									"    }",
									"    if (response.data && response.data.user && response.data.user.id) {",
									"        pm.collectionVariables.set('userId', response.data.user.id);",
									"        console.log('âœ… Charlie user ID saved:', response.data.user.id);",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [{"key": "Content-Type", "value": "application/json"}],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"username\": \"charlie_dev\",\n  \"email\": \"charlie@discordclone.com\",\n  \"password\": \"charlie123456\",\n  \"phone\": \"+1234567892\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/auth/register",
							"host": ["{{baseUrl}}"],
							"path": ["auth", "register"]
						}
					}
				},
				{
					"name": "Login Charlie",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response && pm.response.json()) {",
									"    const response = pm.response.json();",
									"    if (response.data && response.data.accessToken) {",
									"        pm.collectionVariables.set('accessToken', response.data.accessToken);",
									"        console.log('âœ… Charlie logged in successfully');",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [{"key": "Content-Type", "value": "application/json"}],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"email\": \"charlie@discordclone.com\",\n  \"password\": \"charlie123456\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/auth/login",
							"host": ["{{baseUrl}}"],
							"path": ["auth", "login"]
						}
					}
				}
			]
		},
		{
			"name": "Profile Management",
			"item": [
				{
					"name": "Get Charlie Profile",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/profile",
							"host": ["{{baseUrl}}"],
							"path": ["users", "profile"]
						}
					}
				},
				{
					"name": "Update Charlie Global Name",
					"request": {
						"method": "PUT",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"globalname\": \"Charlie Brown\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/profile/global-name",
							"host": ["{{baseUrl}}"],
							"path": ["users", "profile", "global-name"]
						}
					}
				},
				{
					"name": "Update Charlie Custom Status",
					"request": {
						"method": "PUT",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"customStatus\": \"Learning Discord Clone Development\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/profile/custom-status",
							"host": ["{{baseUrl}}"],
							"path": ["users", "profile", "custom-status"]
						}
					}
				},
				{
					"name": "Update Charlie Username",
					"request": {
						"method": "PUT",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"username\": \"charlie_updated\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/profile/username",
							"host": ["{{baseUrl}}"],
							"path": ["users", "profile", "username"]
						}
					}
				},
				{
					"name": "Update Charlie Password",
					"request": {
						"method": "PUT",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"currentPassword\": \"charlie123456\",\n  \"newPassword\": \"charlie_new_password\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/profile/password",
							"host": ["{{baseUrl}}"],
							"path": ["users", "profile", "password"]
						}
					}
				}
			]
		},
		{
			"name": "Friends Management",
			"item": [
				{
					"name": "Get Charlie Incoming Requests",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response && pm.response.json()) {",
									"    const response = pm.response.json();",
									"    if (Array.isArray(response.data) && response.data.length > 0) {",
									"        pm.collectionVariables.set('friendshipId', response.data[0].id);",
									"        console.log('âœ… Charlie friendship ID saved:', response.data[0].id);",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/friends/requests/incoming",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "requests", "incoming"]
						}
					}
				},
				{
					"name": "Accept Alice Friend Request",
					"request": {
						"method": "PUT",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"friendshipId\": \"{{friendshipId}}\",\n  \"status\": \"ACCEPTED\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/friends/respond",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "respond"]
						}
					}
				},
				{
					"name": "Accept Bob Friend Request",
					"request": {
						"method": "PUT",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"friendshipId\": \"{{friendshipId}}\",\n  \"status\": \"ACCEPTED\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/friends/respond",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "respond"]
						}
					}
				},
				{
					"name": "Get Charlie Friends List",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/friends",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends"]
						}
					}
				},
				{
					"name": "Get Charlie Outgoing Requests",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/friends/requests/outgoing",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "requests", "outgoing"]
						}
					}
				},
				{
					"name": "Get Mutual Friends with Alice",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/friends/mutual/{{aliceUserId}}",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "mutual", "{{aliceUserId}}"]
						}
					}
				},
				{
					"name": "Get Mutual Friends with Bob",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/friends/mutual/{{bobUserId}}",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "mutual", "{{bobUserId}}"]
						}
					}
				},
				{
					"name": "Check Friendship with Alice",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/friends/check/{{aliceUserId}}",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "check", "{{aliceUserId}}"]
						}
					}
				},
				{
					"name": "Check Friendship with Bob",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/friends/check/{{bobUserId}}",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "check", "{{bobUserId}}"]
						}
					}
				},
				{
					"name": "Remove Friend Alice",
					"request": {
						"method": "DELETE",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"userId\": \"{{aliceUserId}}\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/friends/remove",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "remove"]
						}
					}
				},
				{
					"name": "Remove Friend Bob",
					"request": {
						"method": "DELETE",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"userId\": \"{{bobUserId}}\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/friends/remove",
							"host": ["{{baseUrl}}"],
							"path": ["users", "friends", "remove"]
						}
					}
				}
			]
		},
		{
			"name": "User Relations",
			"item": [
				{
					"name": "Block Alice",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response && pm.response.json()) {",
									"    const response = pm.response.json();",
									"    if (response.data && response.data.id) {",
									"        pm.collectionVariables.set('relationId', response.data.id);",
									"        console.log('âœ… Alice blocked successfully');",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"targetUserId\": \"{{aliceUserId}}\",\n  \"type\": \"BLOCKED\",\n  \"note\": \"Unwanted contact\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/relations",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations"]
						}
					}
				},
				{
					"name": "Ignore Bob",
					"request": {
						"method": "POST",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"targetUserId\": \"{{bobUserId}}\",\n  \"type\": \"IGNORED\",\n  \"note\": \"Too many messages\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/relations",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations"]
						}
					}
				},
				{
					"name": "Mute Alice",
					"request": {
						"method": "POST",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"targetUserId\": \"{{aliceUserId}}\",\n  \"type\": \"MUTED\",\n  \"note\": \"Too many notifications\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/relations",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations"]
						}
					}
				},
				{
					"name": "Get All Relations",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/relations",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations"]
						}
					}
				},
				{
					"name": "Get Blocked Users",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/relations/blocked",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations", "blocked"]
						}
					}
				},
				{
					"name": "Get Ignored Users",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/relations/ignored",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations", "ignored"]
						}
					}
				},
				{
					"name": "Get Muted Users",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/relations/muted",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations", "muted"]
						}
					}
				},
				{
					"name": "Check Relation with Alice",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/relations/check?targetUserId={{aliceUserId}}&type=BLOCKED",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations", "check"],
							"query": [
								{"key": "targetUserId", "value": "{{aliceUserId}}"},
								{"key": "type", "value": "BLOCKED"}
							]
						}
					}
				},
				{
					"name": "Update Relation Note",
					"request": {
						"method": "PUT",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"targetUserId\": \"{{aliceUserId}}\",\n  \"type\": \"BLOCKED\",\n  \"note\": \"Updated reason for blocking\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/relations/note",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations", "note"]
						}
					}
				},
				{
					"name": "Remove Block from Alice",
					"request": {
						"method": "DELETE",
						"header": [
							{"key": "Content-Type", "value": "application/json"},
							{"key": "Authorization", "value": "{{accessToken}}"}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"targetUserId\": \"{{aliceUserId}}\",\n  \"type\": \"BLOCKED\"\n}"
						},
						"url": {
							"raw": "{{baseUrl}}/users/relations",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations"]
						}
					}
				},
				{
					"name": "Get Relation Stats",
					"request": {
						"method": "GET",
						"header": [{"key": "Authorization", "value": "{{accessToken}}"}],
						"url": {
							"raw": "{{baseUrl}}/users/relations/stats",
							"host": ["{{baseUrl}}"],
							"path": ["users", "relations", "stats"]
						}
					}
				}
			]
		}
	],
	"variable": [
		{"key": "baseUrl", "value": "http://localhost:3000/api/v1", "type": "string"},
		{"key": "accessToken", "value": "", "type": "string"},
		{"key": "userId", "value": "", "type": "string"},
		{"key": "friendshipId", "value": "", "type": "string"},
		{"key": "aliceUserId", "value": "", "type": "string"},
		{"key": "bobUserId", "value": "", "type": "string"},
		{"key": "relationId", "value": "", "type": "string"}
	]
}


============================================================
FILE: postman/WebSocket_Testing.postman_collection.json
============================================================
{
  "info": {
    "name": "Discord WebSocket API",
    "description": "WebSocket testing for Discord Clone API",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "Connect to WebSocket",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "// Generate WebSocket URL with JWT token",
              "const baseUrl = 'ws://localhost:3000';",
              "const token = pm.collectionVariables.get('accessToken');",
              "",
              "pm.request.url = baseUrl;",
              "pm.request.auth = {",
              "    type: 'jwt',",
              "    jwt: {",
              "        token: token",
              "    }",
              "};",
              "",
              "console.log('Connecting with token:', token);"
            ]
          }
        }
      ],
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "ws://localhost:3000",
          "protocol": "ws",
          "host": ["localhost"],
          "port": "3000"
        },
        "description": "Connect to WebSocket server with JWT authentication"
      },
      "response": []
    },
    {
      "name": "Test Connection with Events",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "pm.test('Connection opened', function() {",
              "    pm.expect(pm.response.code).to.eql(101);",
              "});"
            ]
          }
        }
      ],
      "request": {
        "method": "GET",
        "header": [
          {
            "key": "Authorization",
            "value": "Bearer {{accessToken}}",
            "type": "text"
          }
        ],
        "url": {
          "raw": "ws://localhost:3000",
          "protocol": "ws",
          "host": ["localhost"],
          "port": "3000"
        }
      }
    }
  ],
  "variable": [
    {
      "key": "accessToken",
      "value": "",
      "type": "string"
    },
    {
      "key": "userId",
      "value": "",
      "type": "string"
    }
  ]
}



============================================================
FILE: prisma/migrations/migration_lock.toml
============================================================
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"


============================================================
FILE: prisma/schema.prisma
============================================================
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum UserStatus {
  ONLINE
  Invisible
  IDLE
  DND
}

model User {
  id             BigInt             @id
  username       String             @unique
  globalname     String?
  email          String?            @unique
  phone          String?            @unique
  password       String
  avatar         String?
  birthdate      DateTime?
  isBot          Boolean            @default(false)
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt

  // relations
  presence       Presence?
  statusRecord   UserStatusRecord?

  sentMessages     Message[]          @relation("SentMessages")
  receivedMessages Message[]          @relation("ReceivedMessages")
  friendships1     Friendship[]       @relation("UserFriend1")
  friendships2     Friendship[]       @relation("UserFriend2")
  conversations    ConversationUser[]
  messageReceipts  MessageReceipt[]
  sourceRelations  UserRelation[]     @relation("SourceUser")
  targetRelations  UserRelation[]     @relation("TargetUser")

  @@index([username])
}

model Presence {
  id          BigInt      @id
  userId      BigInt      @unique
  user        User        @relation(fields: [userId], references: [id])
  status      UserStatus?
  expiresAt   DateTime?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model UserStatusRecord {
  id           BigInt      @id
  userId       BigInt      @unique
  user         User        @relation(fields: [userId], references: [id])
  text   String?
  emoji  String?
  expiresAt    DateTime?
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
}


model Friendship {
  id        BigInt           @id
  user1     User             @relation("UserFriend1", fields: [user1Id], references: [id])
  user1Id   BigInt
  user2     User             @relation("UserFriend2", fields: [user2Id], references: [id])
  user2Id   BigInt
  status    FriendshipStatus @default(PENDING)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
}

model Conversation {
  id        BigInt   @id
  isGroup   Boolean  @default(false)
  title     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages     Message[]
  participants ConversationUser[]

  @@index([isGroup])
}

model ConversationUser {
  id                BigInt       @id
  user              User         @relation(fields: [userId], references: [id])
  userId            BigInt
  conversation      Conversation @relation(fields: [conversationId], references: [id])
  conversationId    BigInt
  joinedAt          DateTime     @default(now())
  nickname          String?
  // last_read points to last message id read by this user in this convo (for unread count)
  lastReadMessageId BigInt?

  @@unique([userId, conversationId])
  @@index([conversationId])
  @@index([userId])
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  SYSTEM
  REPLY
  VOICE
}

model Message {
  id             BigInt        @id @default(autoincrement())
  conversation   Conversation? @relation(fields: [conversationId], references: [id])
  conversationId BigInt?
  sender         User          @relation("SentMessages", fields: [senderId], references: [id])
  senderId       BigInt
  receiver       User?         @relation("ReceivedMessages", fields: [receiverId], references: [id])
  receiverId     BigInt?

  // Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
  content String?
  type    MessageType @default(TEXT)

  // mentions system
  mentionEveryone Boolean @default(false)
  mentions        Json? // array of Mention objects
  mentionRoles    Json? // array of MentionRole objects

  // metadata
  pinned      Boolean @default(false)
  reactions   Json? // array of Reaction objects
  attachments Json? // array of Attachment objects

  // reply system
  replyTo        BigInt?
  repliedMessage Message?  @relation("MessageReplies", fields: [replyTo], references: [id])
  replies        Message[] @relation("MessageReplies")

  // timestamps
  editedAt  DateTime?
  deletedAt DateTime?
  createdAt DateTime  @default(now())

  receipts MessageReceipt[]

  @@index([conversationId])
  @@index([senderId])
  @@index([receiverId])
  @@index([createdAt])
}

model MessageReceipt {
  id        BigInt   @id
  message   Message  @relation(fields: [messageId], references: [id])
  messageId BigInt
  user      User     @relation(fields: [userId], references: [id])
  userId    BigInt
  readAt    DateTime @default(now())

  @@unique([messageId, userId])
  @@index([userId])
}

model UserRelation {
  id        BigInt       @id
  source    User         @relation("SourceUser", fields: [sourceId], references: [id])
  sourceId  BigInt
  target    User         @relation("TargetUser", fields: [targetId], references: [id])
  targetId  BigInt
  type      RelationType
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  note      String?

  @@unique([sourceId, targetId, type])
  @@index([sourceId])
  @@index([targetId])
}

enum RelationType {
  BLOCKED
  IGNORED
  MUTED
}


============================================================
FILE: test/jest-e2e.json
============================================================
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}


============================================================
FILE: eslint.config.mjs
============================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      sourceType: 'commonjs',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'warn',
      '@typescript-eslint/no-unsafe-argument': 'warn'
    },
  },
);


============================================================
FILE: nest-cli.json
============================================================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}


============================================================
FILE: package.json
============================================================
{
  "name": "discord_clone",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json"
  },
  "dependencies": {
    "@nestjs/common": "^11.1.6",
    "@nestjs/config": "^4.0.2",
    "@nestjs/core": "^11.1.6",
    "@nestjs/jwt": "^11.0.1",
    "@nestjs/platform-express": "^11.0.1",
    "@nestjs/platform-socket.io": "^11.1.7",
    "@nestjs/swagger": "^11.2.1",
    "@nestjs/websockets": "^11.1.7",
    "@prisma/client": "^6.17.1",
    "@sapphire/snowflake": "^3.5.5",
    "argon2": "^0.44.0",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.2",
    "ioredis": "^5.8.1",
    "ms": "^2.1.3",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "socket.io": "^4.8.1",
    "socket.io-redis-adapter": "^8.4.6",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@types/express": "^5.0.0",
    "@types/jest": "^30.0.0",
    "@types/ms": "^2.1.0",
    "@types/node": "^22.10.7",
    "@types/supertest": "^6.0.2",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^30.0.0",
    "prettier": "^3.4.2",
    "prisma": "^6.17.1",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}


============================================================
FILE: README.md
============================================================
# Discord Clone Backend

Backend API Ù„Ù€ Discord Clone Ù…Ø¨Ù†ÙŠ Ø¨Ù€ NestJS Ù…Ø¹ Ù†Ø¸Ø§Ù… Presence Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Redis.

---

## ğŸ“š Documentation

### ğŸš€ Quick Start
- **[Quick Start Guide](./docs/QUICK_START_GUIDE.md)** - Ø¯Ù„ÙŠÙ„ Ø³Ø±ÙŠØ¹ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù€ APIs

### ğŸ“– API Documentation
- **[API Documentation](./docs/API_DOCUMENTATION.md)** - ØªÙØ§ØµÙŠÙ„ ÙƒØ§Ù…Ù„Ø© Ù„Ø¬Ù…ÙŠØ¹ REST APIs

### ğŸ”´ Presence System
- **[Redis Presence System](./docs/REDIS_PRESENCE_SYSTEM.md)** - Ù†Ø¸Ø§Ù… Presence Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Redis (Ù…Ø«Ù„ Discord)
- **[Status System](./docs/STATUS_SYSTEM.md)** - Ø´Ø±Ø­ Display Status vs Connection Status

### ğŸ”Œ WebSocket
- **[Socket.IO Guide](./docs/SOCKET_IO_GUIDE.md)** - Ø¯Ù„ÙŠÙ„ WebSocket Events
- **[WebSocket Testing](./docs/WEBSOCKET_POSTMAN_TESTING.md)** - ÙƒÙŠÙÙŠØ© Testing WebSocket

### ğŸ—ï¸ Architecture
- **[Backend Architecture](./docs/BACKEND_ARCHITECTURE.md)** - Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø©

---

## âœ¨ Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©

âœ… **Redis-Based Presence System** - Ù†Ø¸Ø§Ù… presence Ù…Ø«Ù„ Discord ØªÙ…Ø§Ù…Ø§Ù‹  
âœ… **Real-time Status Updates** - ØªØ­Ø¯ÙŠØ«Ø§Øª ÙÙˆØ±ÙŠØ© Ø¹Ø¨Ø± WebSocket  
âœ… **Friends System** - Ù†Ø¸Ø§Ù… Ø£ØµØ¯Ù‚Ø§Ø¡ ÙƒØ§Ù…Ù„  
âœ… **User Relations** - Block, Ignore, Mute  
âœ… **JWT Authentication** - Ø£Ù…Ø§Ù† Ø¹Ø§Ù„ÙŠ  
âœ… **Scalable Architecture** - ÙŠØ¯Ø¹Ù… Multi-instance deployment  

---

## ğŸš€ Quick Start

### Installation

```bash
npm install
```

### Environment Setup

Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù `.env`:

```env
DATABASE_URL=postgresql://user:password@localhost:5432/discord_clone
CACHE_HOST=localhost
CACHE_PORT=6379
CACHE_PASS=
JWT_SECRET_ACCESS=your_secret_key
JWT_EXPIRES_IN=7d
PORT=3000
```

### Database Setup

```bash
npx prisma migrate dev
npx prisma generate
```

### Run Application

```bash
# Development
npm run start:dev

# Production
npm run build
npm run start:prod
```

---

## ğŸ“‹ Tech Stack

- **Framework**: NestJS
- **Database**: PostgreSQL + Prisma
- **Cache/Presence**: Redis
- **WebSocket**: Socket.IO
- **Authentication**: JWT
- **Validation**: Class Validator

---

## ğŸ”‘ Key Features

### 1. Redis Presence System
- âœ… Presence ÙÙŠ Redis ÙÙ‚Ø· (volatile)
- âœ… Auto-cleanup Ø¹Ù†Ø¯ restart
- âœ… Real-time status updates
- âœ… Multi-instance support

### 2. REST APIs
- âœ… Authentication (Register/Login)
- âœ… Profile Management
- âœ… Friends System
- âœ… User Relations (Block/Ignore/Mute)

### 3. WebSocket
- âœ… Real-time presence updates
- âœ… Friend request notifications
- âœ… Status changes broadcasting

---

## ğŸ“– API Examples

### Get Profile

```http
GET /api/v1/users/@me
Authorization: Bearer <token>
```

**Response:**
```json
{
  "data": {
    "id": "5280662395293696",
    "username": "john_doe",
    "isOnline": true,    // âœ… From Redis (real-time)
    "status": "ONLINE"   // âœ… Display status
  }
}
```

### Update Status

```http
PUT /api/v1/users/@me/update/presenceStatus
Authorization: Bearer <token>
Content-Type: application/json

{
  "status": "IDLE"
}
```

---

## ğŸ”Œ WebSocket Connection

```javascript
import io from 'socket.io-client';

const socket = io('http://localhost:3000', {
  auth: { token: 'your_jwt_token' }
});

socket.on('connected', (data) => {
  console.log('Connected:', data.userId);
});

socket.on('presence:updated', (data) => {
  console.log(`${data.username} is now ${data.status}`);
});
```

---

## ğŸ“‚ Project Structure

```
src/
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ auth/              # Authentication
â”‚   â”œâ”€â”€ users/             # User management
â”‚   â””â”€â”€ websocket/         # WebSocket Gateway
â”‚
â”œâ”€â”€ common/
â”‚   â”œâ”€â”€ database/          # Repositories
â”‚   â”œâ”€â”€ Global/cache/      # Redis services
â”‚   â””â”€â”€ guards/            # Auth guards
â”‚
â””â”€â”€ main.ts
```

---

## ğŸ“š Documentation Files

| File | Description |
|------|-------------|
| [QUICK_START_GUIDE.md](./docs/QUICK_START_GUIDE.md) | Ø¯Ù„ÙŠÙ„ Ø³Ø±ÙŠØ¹ Ù„Ù„Ø¨Ø¯Ø¡ |
| [API_DOCUMENTATION.md](./docs/API_DOCUMENTATION.md) | ØªÙØ§ØµÙŠÙ„ REST APIs |
| [REDIS_PRESENCE_SYSTEM.md](./docs/REDIS_PRESENCE_SYSTEM.md) | Ù†Ø¸Ø§Ù… Presence |
| [BACKEND_ARCHITECTURE.md](./docs/BACKEND_ARCHITECTURE.md) | Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ© |
| [SOCKET_IO_GUIDE.md](./docs/SOCKET_IO_GUIDE.md) | WebSocket Guide |
| [STATUS_SYSTEM.md](./docs/STATUS_SYSTEM.md) | Status System |

---

## ğŸ§ª Testing

### Test WebSocket

Ø§ÙØªØ­ `public/websocket-test.html` ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­ Ù„Ù€ testing Ù…Ø¨Ø§Ø´Ø±.

### Postman Collections

Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù€ collections Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ `postman/`:
- `User1_Alice.postman_collection.json`
- `User2_Bob.postman_collection.json`
- `User3_Charlie.postman_collection.json`
- `WebSocket_Testing.postman_collection.json`

---

## âš™ï¸ Configuration

### Required Services

1. **PostgreSQL** - Database
2. **Redis** - Cache & Presence
3. **Node.js** - Runtime

### Environment Variables

Ø±Ø§Ø¬Ø¹ [Quick Start Guide](./docs/QUICK_START_GUIDE.md) Ù„Ù„Ù€ environment variables Ø§Ù„ÙƒØ§Ù…Ù„Ø©.

---

## ğŸ› Troubleshooting

### Presence Issues

Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠØ¸Ù‡Ø± online ÙˆÙ‡Ùˆ offline:
- âœ… Ø§Ø³ØªØ®Ø¯Ù… `getPresenceStatus()` Ù…Ù† Redis
- âŒ Ù„Ø§ ØªØ³ØªØ®Ø¯Ù… `isOnline` Ù…Ù† Database

Ø±Ø§Ø¬Ø¹ [Redis Presence System](./docs/REDIS_PRESENCE_SYSTEM.md) Ù„Ù„ØªÙØ§ØµÙŠÙ„.

---

## ğŸ“ Important Notes

### âœ… DO

- âœ… Ø§Ø³ØªØ®Ø¯Ù… Redis Ù„Ù„Ù€ presence
- âœ… Ø§Ø³ØªØ®Ø¯Ù… REST API Ù„ØªØ­Ø¯ÙŠØ« Status
- âœ… Ø§Ø³ØªÙ…Ø¹ Ù„Ù€ WebSocket events

### âŒ DON'T

- âŒ Ù„Ø§ ØªØ³ØªØ®Ø¯Ù… Database `isOnline` field
- âŒ Ù„Ø§ ØªÙØ­Ø¯Ø« `isOnline` ÙÙŠ Database
- âŒ Ù„Ø§ ØªØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Database Ù„Ù„Ù€ presence

---

## ğŸ”— Links

- [API Documentation](./docs/API_DOCUMENTATION.md)
- [Quick Start](./docs/QUICK_START_GUIDE.md)
- [Redis Presence](./docs/REDIS_PRESENCE_SYSTEM.md)
- [Architecture](./docs/BACKEND_ARCHITECTURE.md)

---

## ğŸ“„ License

Private project

---

**Last Updated:** 2024-01-15


============================================================
FILE: tsconfig.build.json
============================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}


============================================================
FILE: tsconfig.json
============================================================
{
  "compilerOptions": {
    "module": "CommonJS",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "isolatedModules": true,
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false
  }
}